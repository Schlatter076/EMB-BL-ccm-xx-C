/*******************************************************************************
  * File    : "projCfg.h"
  * Author  : kensky
  * Version :
  * Date    : 2019-12-03
  * Brief   : There will always be such a global cfg file like this one in each
              project being developed, which can configure necessary parameters
              controlling the behaviors of the program. Though developers ,with
              much experience and knowledge about the modules, can still use
              individual cfg file in each module, it will be much more convenient
              and clear to handle those parameters here!
*******************************************************************************/
#ifndef   __PROJECT_CONFIGURATION_H_20191203YK
#define   __PROJECT_CONFIGURATION_H_20191203YK

/**** Includes ****************************************************************/
#include "./Proj_cfg/inc/projSpec.h"
#include "./Proj_cfg/inc/projRetValue.h"
#include "./Proj_cfg/inc/projCompiler.h"

extern volatile unsigned char gv_testBreakPoint;

// NRF52832, coordinator tp-link
/**** Defines *****************************************************************/
#define __DAHAOx // enable dahao project

#define __UUIDx                 (0x91198E9928445F81ull)

#ifdef __UUID
// #define __PID_LST_BYTE_GLOBAL   (0x23)
#define __UUID0                 (__UUID)
#define __UUID1                 (0x91198E9928445F81ull)
#endif // __UUID

#define __ADDR_FREE_MEM         (0x20003400)

/**** MCU Interface ***********************************************************/
#define __MCU_TYPE              (_MCU_IS_STM32F4xx) // */ (_MCU_IS_NRF51822)

#if   (__MCU_TYPE == _MCU_IS_STM32L0x)
#define __MCU_CLKSRC            /* __RCC_HSID1_NPLL_STM32L0 // __RCC_HSID1_NPLL_LSE_STM32L0 // */ /* __RCC_2_10MHZ_MSI_LSE_STM32L0 // */ __RCC_4_20MHZ_LSE_STM32L0
#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define __MCU_SYSCLK            __RCC_72MHZ_HSE25_PLL_CL
#define __MCU_FREQ              (72000000ul)
#define HSE_VALUE               (25000000ul)
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#define __MCU_CLKSRC            __RCC_HSI14_LSE_EFM32TGxx
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define __MCU_FREQ              (40000000ul)
#define HSE_VALUE               (40000000ul)
#define __MCU_CLKSRC            __RCC_HSED1_NPLL_EFR32yGxx
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define __MCU_FREQ              (16000000ul)
#define HSE_VALUE               (16000000ul)
// __MCU_CLKSRC : not necessary
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define __MCU_FREQ              (64000000ul)
#define HSE_VALUE               (32000000ul)
// __MCU_CLKSRC : not necessary
#elif (__MCU_TYPE == _MCU_IS_STM32F4xx)
#define __MCU_FREQ              (180000000ull)
#define HSE_VALUE               (12000000ull)
#else
#error "please specify the mcu type"
#endif

#define __MCU_ADDR_SPACE        (_MCU_IS_32_BITS)
#define __MCU_LPWR_STRATEGY     (_MCU_LPWR_STOP)

#define ICACHE_FLASH_ATTR
#define ICACHE_RODATA_ATTR

#define __EN_RAM_EXECUTIONx

/**** module switch ***********************************************************/
/*******************************************************************************
 *                      Global configuration SW
 *  If the MACRO below has been defined, the current configuration file will
 *  override all other configuration files in each module separately.
 *  So, developer can make global configuration just in the same location, which
 *  will considerably make configuration easier and clearer.
*******************************************************************************/
#define __PROJ_CONFIGURATION          (_GLOBAL_CONFIGURED)
#define __RELEASE_MODE                (_MODULE_OFF)
#define __KS_PERIPH_MODULE            (_MODULE_ON)
#define __DELAY_MODULE                (_MODULE_OFF)
#define __IR_MODULE                   (_MODULE_OFF)
#define __TRACER_MODULE               (_MODULE_ON)
#define __sFLASH_MODULE               (_MODULE_OFF)
#define __uCOS_MODULE                 (_MODULE_OFF)
#define __RTT_MODULE                  (_MODULE_OFF)
#define __STFWLIB_MODULE              (_MODULE_ON)
#define __RADIO_MODULE                (_MODULE_OFF)
#define __KEYPADS_MODULE              (_MODULE_OFF)
#define __LEDs_MODULE                 (_MODULE_OFF)
#define __LWIP_MODULE                 (_MODULE_OFF) // also indicate we will use ETH module
#define __LCD_sFLASH_MODULE           (_MODULE_OFF)
#define __SMS_MODULE                  (_MODULE_OFF)
#define __E2ROM_MODULE                (_MODULE_OFF)
#define __RULEOS_MODULE               (_MODULE_OFF)
#define __MEMS_MODULE                 (_MODULE_OFF)
#define __KSHCI_MODULE                (_MODULE_OFF)
#define __ETHCTRL_MODULE              (_MODULE_OFF)

#if (defined __PROJ_CONFIGURATION) && (__PROJ_CONFIGURATION == _GLOBAL_CONFIGURED)

/**** RL Periph Module ********************************************************/
#if (defined __KS_PERIPH_MODULE) && (_MODULE_ON == __KS_PERIPH_MODULE)

#define __USE_YK_ASSERT
#define USE_DEFAULT_YK_ASSERT   // use the assert in the ksPeriph
#define __MCU_ENDIAN                  (_MCU_is_LITTLE_ENDIAN)

#endif

/**** STM32FWLib **************************************************************/
#if (defined __STFWLIB_MODULE) && (_MODULE_ON == __STFWLIB_MODULE)

#define USE_STDPERIPH_DRIVER
#define USE_FULL_ASSERT
#define USE_FULL_FILENAMEx
#define NDEBUG
#define USE_EXTERNAL_PROJECT_IT_Hx // whether to use the nrf51_52_it.c in fwlib
#define __CORTEX_IRQ_PrioGRP           (NVIC_PriorityGroup_0)

#if   (__MCU_TYPE == _MCU_IS_STM32F10x)
//#define STM32F10X_LD    // STM32 Low density devices (16-32kb flash)
//#define STM32F10X_LD_VL // STM32 Low density Value Line devices
//#define STM32F10X_MD    // STM32 Medium density devices (64-128kb flash)
//#define STM32F10X_MD_VL // STM32 Medium density Value Line devices
//#define STM32F10X_HD    // STM32 High density devices (256-512kb flash)
//#define STM32F10X_HD_VL // STM32 High density value line devices
//#define STM32F10X_XL    // STM32 XL-density devices (768-1024kb flash)
#define STM32F10X_CL    // STM32 Connectivity line devices (105 & 107)
#elif (__MCU_TYPE == _MCU_IS_STM32L1x)
#define STM32L1XX_MD
//#define STM32L1XX_MDP
//#define STM32L1XX_HD
#elif (__MCU_TYPE == _MCU_IS_STM32F4xx)
#define USE_HAL_DRIVE

#ifndef STM32F429_439xx
#define STM32F429_439xx
#endif

#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define USE_HAL_DRIVER
#define STM32L051xx
// #define STM32L052xx
//#define STM32L053xx
//#define STM32L061xx
//#define STM32L062xx
//#define STM32L063xx
#elif (__MCU_TYPE == _MCU_IS_STN32F0xx)
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#if (defined USE_FULL_ASSERT)
#define DEBUG_EFMx
#endif
//#define EFM32TG108F16
//#define EFM32TG108F32
//#define EFM32TG108F4
//#define EFM32TG108F8
//#define EFM32TG110F16
//#define EFM32TG110F32
//#define EFM32TG110F4
//#define EFM32TG110F8
//#define EFM32TG210F16
#define EFM32TG210F32
//#define EFM32TG210F8
//#define EFM32TG222F16
//#define EFM32TG222F32
//#define EFM32TG222F8
//#define EFM32TG225F16
//#define EFM32TG225F32
//#define EFM32TG225F8
//#define EFM32TG230F16
//#define EFM32TG230F32
//#define EFM32TG230F8
//#define EFM32TG232F16
//#define EFM32TG232F32
//#define EFM32TG232F8
//#define EFM32TG822F16
//#define EFM32TG822F32
//#define EFM32TG822F8
//#define EFM32TG825F16
//#define EFM32TG825F32
//#define EFM32TG825F8
//#define EFM32TG840F16
//#define EFM32TG840F32
//#define EFM32TG840F8
//#define EFM32TG842F16
//#define EFM32TG842F32
//#define EFM32TG842F8
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define NRF52
#define CLOCK_ENABLED                           (1)
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define NRF51
#define CLOCK_ENABLED                           (1)

#define CLOCK_CONFIG_XTAL_FREQ                  CLOCK_XTALFREQ_XTALFREQ_16MHz // 16 MHZ xtal
#define CLOCK_CONFIG_LF_SRC                     CLOCK_LFCLKSRC_SRC_Xtal       // 32768 xtal

#define GPIOTE_ENABLED                          (0)
#define TIMER0_ENABLED                          (0)
#define TIMER1_ENABLED                          (0)
#define TIMER2_ENABLED                          (0)
#define TIMER3_ENABLED                          (0)
#define TIMER4_ENABLED                          (0)
#define RTC0_ENABLED                            (0)
#define RTC1_ENABLED                            (1)
#define RNG_ENABLED                             (0)
#define PWM0_ENABLED                            (0)
#define PWM1_ENABLED                            (0)
#define PWM2_ENABLED                            (0)
#define SPI0_ENABLED                            (0)
#define SPI1_ENABLED                            (0)
#define SPI2_ENABLED                            (0)
#define SPIS0_ENABLED                           (0)
#define SPIS1_ENABLED                           (1)
#define SPIS2_ENABLED                           (0)
#define UART0_ENABLED                           (1)
#define TWI0_ENABLED                            (0)
#define TWI1_ENABLED                            (0)
#define TWIS0_ENABLED                           (0)
#define TWIS1_ENABLED                           (0)
#define QDEC_ENABLED                            (0)
#define SAADC_ENABLED                           (0)
#define PDM_ENABLED                             (0)
#define LPCOMP_ENABLED                          (0)
#define WDT_ENABLED                             (0)
#define I2S_ENABLED                             (0)

#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#if (defined USE_FULL_ASSERT)
#define DEBUG_EFMx
#endif
#define EFR32BG1P232F256GM32
// #define EFR32BG1P232F256GJ43

#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define NRF52

#define CLOCK_ENABLED                           (1)

#define CLOCK_CONFIG_XTAL_FREQ                  NRF_CLOCK_XTALFREQ_Default // 16 MHZ xtal
#define CLOCK_CONFIG_LF_SRC                     CLOCK_LFCLKSRC_SRC_Xtal       // 32768 xtal

#define GPIOTE_ENABLED                          (0)
#define TIMER0_ENABLED                          (0)
#define TIMER1_ENABLED                          (0)
#define TIMER2_ENABLED                          (0)
#define TIMER3_ENABLED                          (0)
#define TIMER4_ENABLED                          (0)
#define RTC0_ENABLED                            (0)
#define RTC1_ENABLED                            (0)
#define RNG_ENABLED                             (0)
#define PWM0_ENABLED                            (0)
#define PWM1_ENABLED                            (0)
#define PWM2_ENABLED                            (0)
#define SPI0_ENABLED                            (0)
#define SPI1_ENABLED                            (0)
#define SPI2_ENABLED                            (0)
#define SPIS0_ENABLED                           (0)
#define SPIS1_ENABLED                           (1)
#define SPIS2_ENABLED                           (0)
#define UART0_ENABLED                           (0)
#define TWI0_ENABLED                            (0)
#define TWI1_ENABLED                            (0)
#define TWIS0_ENABLED                           (0)
#define TWIS1_ENABLED                           (0)
#define QDEC_ENABLED                            (0)
#define SAADC_ENABLED                           (0)
#define PDM_ENABLED                             (0)
#define LPCOMP_ENABLED                          (0)
#define WDT_ENABLED                             (0)
#define I2S_ENABLED                             (0)

#else
#error "unsupportted"
#endif // 1

#endif

//#if defined _MODULE_ON
/**** uCOS290 Module **********************************************************/
#if (defined __uCOS_MODULE) && (_MODULE_ON == __uCOS_MODULE)
#endif

/**** RT Thread Module ********************************************************/
#if (defined __RTT_MODULE) && (_MODULE_ON == __RTT_MODULE)
/**** board configuration *****************************************************/
// <o> SDCard Driver <1=>SDIO sdcard <0=>SPI MMC card
//  <i>Default: 1
#define STM32_USE_SDIO          1

/**** whether use board external SRAM memory **********************************/
// <e>Use external SRAM memory on the board
//  <i>Enable External SRAM memory
#define STM32_EXT_SRAM          0
//  <o>Begin Address of External SRAM
//      <i>Default: 0x68000000
/**** the begining address of external SRAM ***********************************/
#define STM32_EXT_SRAM_BEGIN    0x68000000
//  <o>End Address of External SRAM
//      <i>Default: 0x68080000
/**** the end address of external SRAM ****************************************/
#define STM32_EXT_SRAM_END      0x68080000
// </e>

// <o> Internal SRAM memory size[Kbytes] <8-64>
//  <i>Default: 64
#define STM32_SRAM_SIZE         20
#define STM32_SRAM_END          (0x20000000 + STM32_SRAM_SIZE * 1024)

// <o> Console on USART: <0=> no console <1=>USART 1 <2=>USART 2 <3=> USART 3
//  <i>Default: 1
#define STM32_CONSOLE_USART     2

#if STM32_CONSOLE_USART == 0
#define CONSOLE_DEVICE "no"
#elif STM32_CONSOLE_USART == 1
#define CONSOLE_DEVICE "uart1"
#elif STM32_CONSOLE_USART == 2
#define CONSOLE_DEVICE "uart2"
#elif STM32_CONSOLE_USART == 3
#define CONSOLE_DEVICE "uart3"
#endif

// <o> Ethernet Interface: <0=> Microchip ENC28J60 <1=> Davicom DM9000A
//  <i>Default: 0
#define STM32_ETH_IF            1

/**** rtconfig ****************************************************************/
/**** Includes ****************************************************************/
#include "../Libs/RTT-Lite/rt_spec.h"

/**** Defines *****************************************************************/
#define     __RT_PRINTF_STATUS          _RT_MODULE_is_ON
#define     __RT_DEBUG_STATUS           _RT_MODULE_is_ON
#define     __RT_ASSERT_STATUS          _RT_MODULE_is_ON

#define     RT_NAME_MAX                 8
#define     RT_ALIGN_SIZE               4
#define     RT_THREAD_PRIORITY_MAX      32
#define     RT_TICK_PER_SECOND          100

/* SECTION: RT_DEBUG */
/**** Thread Debug ************************************************************/
#define     RT_DEBUG
#define     RT_THREAD_DEBUG
#define     RT_USING_OVERFLOW_CHECK
#define     RT_USING_HOOK

/**** Using Software Timer ****************************************************/
//#define     RT_USING_TIMER_SOFT
#define     RT_TIMER_THREAD_PRIO        4
#define     RT_TIMER_THREAD_STACK_SIZE  512
#define     RT_TIMER_TICK_PER_SECOND    10

/**** SECTION: IPC ************************************************************/
#define     RT_USING_SEMAPHORE      /* Using Semaphore*/
#define     RT_USING_MUTEX          /* Using Mutex */
#define     RT_USING_EVENT          /* Using Event */
#define     RT_USING_MAILBOX        /* Using MailBox */
#define     RT_USING_MESSAGEQUEUE   /* Using Message Queue */

/**** SECTION: Memory Management **********************************************/
#define     RT_USING_MEMPOOL        /* Using Memory Pool Management*/
#define     RT_USING_HEAP           /* Using Dynamic Heap Management */
#define     RT_USING_SMALL_MEM      /* Using Small MM */

/**** SECTION: Device System **************************************************/
#define     RT_USING_DEVICE         /* Using Device System */
#define     RT_USING_UART2

/**** SECTION: Console options ************************************************/
#define     RT_USING_CONSOLE
/**** the buffer size of console **********************************************/
#define     RT_CONSOLEBUF_SIZE          128
//#define     RT_USING_FINSH          /* SECTION: finsh, a C-Express shell */
#define     FINSH_USING_SYMTAB      /* Using symbol table */
#define     FINSH_USING_DESCRIPTION

/**** SECTION: device filesystem **********************************************/
//#define     RT_USING_DFS
#define     RT_USING_DFS_ELMFAT
#define     RT_DFS_ELM_WORD_ACCESS
/* Reentrancy (thread safe) of the FatFs module.  */
#define     RT_DFS_ELM_REENTRANT
/* Number of volumes (logical drives) to be used. */
#define     RT_DFS_ELM_DRIVES           2
/* #define RT_DFS_ELM_USE_LFN           1 */
#define     RT_DFS_ELM_MAX_LFN          255
/* Maximum sector size to be handled. */
#define     RT_DFS_ELM_MAX_SECTOR_SIZE  512

/* the max number of mounted filesystem */
#define     DFS_FILESYSTEMS_MAX         2
/* the max number of opened files       */
#define     DFS_FD_MAX                  4

/* SECTION: lwip, a lighwight TCP/IP protocol stack */
/* #define RT_USING_LWIP */
/* LwIP uses RT-Thread Memory Management */
#define     RT_LWIP_USING_RT_MEM
#define     RT_LWIP_ICMP        /* Enable ICMP protocol*/
#define     RT_LWIP_UDP         /* Enable UDP protocol*/
#define     RT_LWIP_TCP         /* Enable TCP protocol*/
#define     RT_LWIP_DNS         /* Enable DNS */

/**** the number of simulatenously active TCP connections *********************/
#define     RT_LWIP_TCP_PCB_NUM         5

/**** Using DHCP **************************************************************/
//#define     RT_LWIP_DHCP

/**** ip address of target ****************************************************/
#define     RT_LWIP_IPADDR0             192
#define     RT_LWIP_IPADDR1             168
#define     RT_LWIP_IPADDR2             1
#define     RT_LWIP_IPADDR3             30

/**** gateway address of target ***********************************************/
#define     RT_LWIP_GWADDR0             192
#define     RT_LWIP_GWADDR1             168
#define     RT_LWIP_GWADDR2             1
#define     RT_LWIP_GWADDR3             1

/**** mask address of target **************************************************/
#define     RT_LWIP_MSKADDR0            255
#define     RT_LWIP_MSKADDR1            255
#define     RT_LWIP_MSKADDR2            255
#define     RT_LWIP_MSKADDR3            0

/**** tcp thread options ******************************************************/
#define     RT_LWIP_TCPTHREAD_PRIORITY  12
#define     RT_LWIP_TCPTHREAD_MBOX_SIZE 10
#define     RT_LWIP_TCPTHREAD_STACKSIZE 1024

/**** ethernet if thread options **********************************************/
#define     RT_LWIP_ETHTHREAD_PRIORITY  15
#define     RT_LWIP_ETHTHREAD_MBOX_SIZE 10
#define     RT_LWIP_ETHTHREAD_STACKSIZE 512

/**** TCP sender buffer space *************************************************/
#define     RT_LWIP_TCP_SND_BUF         8192
/**** TCP receive window. *****************************************************/
#define     RT_LWIP_TCP_WND             8192

/**** SECTION: RT-Thread/GUI **************************************************/
//#define     RT_USING_RTGUI
/**** name length of RTGUI object *********************************************/
#define     RTGUI_NAME_MAX              12
/**** support 16 weight font **************************************************/
#define     RTGUI_USING_FONT16
/**** support Chinese font ****************************************************/

#define     RTGUI_USING_FONTHZ
/**** use DFS as file interface ***********************************************/
#define     RTGUI_USING_DFS_FILERW
/**** use font file as Chinese font *******************************************/
#define     RTGUI_USING_HZ_FILE
/**** use Chinese bitmap font *************************************************/
#define     RTGUI_USING_HZ_BMP
/**** use small size in RTGUI *************************************************/
#define     RTGUI_USING_SMALL_SIZE
/**** use mouse cursor ********************************************************/
//#define     RTGUI_USING_MOUSE_CURSOR
/**** default font size in RTGUI **********************************************/
#define     RTGUI_DEFAULT_FONT_SIZE     16

/**** image support ***********************************************************/
//#define     RTGUI_IMAGE_XPM
//#define     RTGUI_IMAGE_BMP

// <bool name="RT_USING_CMSIS_OS" description="Using CMSIS OS API" default="true" />
// #define RT_USING_CMSIS_OS
// <bool name="RT_USING_RTT_CMSIS" description="Using CMSIS in RTT" default="true" />
#define     RT_USING_RTT_CMSIS
// <bool name="RT_USING_BSP_CMSIS" description="Using CMSIS in BSP" default="true" />
// #define RT_USING_BSP_CMSIS

#endif // (defined __RTT_MODULE) && (_MODULE_ON == __RTT_MODULE)

/***** Delay Module ***********************************************************/
#if (defined __DELAY_MODULE) && (_MODULE_ON == __DELAY_MODULE)

#define __DELAY_BEBUG                 (_DLY_DBG_is_OFF)
#define __DELAY_SOURCE                (_TIMER_DELAY)       // delay_mode_setting
#if (defined __DELAY_SOURCE) && (_TIMER_DELAY == __DELAY_SOURCE)
#define __DELAY_TIMER_BUS             (is_tim01)  // delay_timer_setting
#define __DELAY_TIMER_USPERTICK       (0x01)      // adjust the value based on YOUR needs!
#define __DELAY_TIMER_MAXTICK         (0xffff)    // adjust the value based on the hardware!
#define __DELAY_TIMER_PRIPRIO         (0) // DELAY will happen in the syncIsr, must be nested
#define __DELAY_TIMER_SUBPRIO         (0) // make sure this isr has the highest priority!!

#if (__RTC_MODULE != _MODULE_OFF)
#define __DELAY_RTC_MS_STATUS         (_RTC_DLY_MS_is_ON)
#else
#define __DELAY_RTC_MS_STATUS         (_RTC_DLY_MS_is_OFF)
#endif
#endif // (_TIMER_DELAY == __DELAY_SOURCE)

#endif // (defined __DELAY_MODULE) && (_MODULE_ON == __DELAY_MODULE)

/***** LEDs Module ************************************************************/
#if (defined __LEDs_MODULE) && (_MODULE_ON == __LEDs_MODULE)
#include <LEDs_Spec.h>

  #define     __LEDS_CNT              (1) // Support 10 LEDs at most

/***** LEDs GPIO Configuration ************************************************/
 #if (__LEDS_CNT > 0) // LED1
  #define     __LED_1_PORT            (io_Port_A)
  #define     __LED_1_PIN             (io_Pin_25)
  #define     __LED_1_DRIVE_MODE      (__LED_HIGH_DRIVE)
 #endif // (__LEDS_CNT > 0)

 #if (__LEDS_CNT > 1) // LED2
  #define     __LED_2_PORT            (io_Port_A)
  #define     __LED_2_PIN             (io_Pin_09)
  #define     __LED_2_DRIVE_MODE      (__LED_HIGH_DRIVE)
 #endif // (__LEDS_CNT > 1)

#if (__LEDS_CNT > 2) // LED 3
  #define     __LED_3_PORT            (io_Port_A)
  #define     __LED_3_PIN             (io_Pin_10)
  #define     __LED_3_DRIVE_MODE      (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 2)

#if (__LEDS_CNT > 3) // LED ETH NET STATUS
  #define     __LED_4_PORT        (io_Port_0)
  #define     __LED_4_PIN         (io_Pin_06)
  #define     __LED_4_DRIVE_MODE  (__LED_LOW_DRIVE)
#endif // (__LEDS_CNT > 3)

#if (__LEDS_CNT > 4)
  #define     __LED_5_PORT        (io_Port_1)
  #define     __LED_5_PIN         (io_Pin_11)
  #define     __LED_5_DRIVE_MODE  (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 4)

#if (__LEDS_CNT > 5)
  #define     __LED_6_PORT        (io_Port_1)
  #define     __LED_6_PIN         (io_Pin_11)
  #define     __LED_6_DRIVE_MODE  (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 5)

#if (__LEDS_CNT > 6)
  #define     __LED_7_PORT        (io_Port_1)
  #define     __LED_7_PIN         (io_Pin_11)
  #define     __LED_7_DRIVE_MODE  (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 6)

#if (__LEDS_CNT > 7)
  #define     __LED_8_PORT        (io_Port_1)
  #define     __LED_8_PIN         (io_Pin_11)
  #define     __LED_8_DRIVE_MODE  (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 7)

#if (__LEDS_CNT > 8)
  #define     __LED_9_PORT        (io_Port_1)
  #define     __LED_9_PIN         (io_Pin_11)
  #define     __LED_9_DRIVE_MODE  (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 8)

#if (__LEDS_CNT > 9)
  #define     __LED_10_PORT       (io_Port_1)
  #define     __LED_10_PIN        (io_Pin_11)
  #define     __LED_10_DRIVE_MODE (__LED_HIGH_DRIVE)
#endif // (__LEDS_CNT > 9)
#endif

/***** E2ROM Module ***********************************************************/
#if (defined __E2ROM_MODULE) && (_MODULE_ON == __E2ROM_MODULE)

#define     __E2ROM_TYPE            (_E2ROM_is_AT24C08)

#define     __E2ROM_CNT             (1)
#define     __E2ROM_SPEED           (is_10MHz)

#if (1 <= __E2ROM_CNT)
#define     __E2ROM_1_BUS           (sI2C)
#define     __E2ROM_1_SDA_PORT      (io_Port_1)
#define     __E2ROM_1_SDA_PIN       (io_Pin_08)
#define     __E2ROM_1_SCL_PORT      (io_Port_1)
#define     __E2ROM_1_SCL_PIN       (io_Pin_09)
#define     __E2ROM_1_WP_PORT       (io_Port_1)
#define     __E2ROM_1_WP_PIN        (io_Pin_07)
#define     __E2ROM_1_DEVADDR       (0x00u) // Only A2~A1
#endif

#if (2 <= __E2ROM_CNT)
#define     __E2ROM_2_SDA_PORT      ()
#define     __E2ROM_2_SDA_PIN       ()
#define     __E2ROM_2_SCL_PORT      ()
#define     __E2ROM_2_SCL_PIN       ()
#define     __E2ROM_2_WP_PORT       ()
#define     __E2ROM_2_WP_PIN        ()
#endif

#if (3 <= __E2ROM_CNT)
#define     __E2ROM_3_SDA_PORT      ()
#define     __E2ROM_3_SDA_PIN       ()
#define     __E2ROM_3_SCL_PORT      ()
#define     __E2ROM_3_SCL_PIN       ()
#define     __E2ROM_3_WP_PORT       ()
#define     __E2ROM_3_WP_PIN        ()
#endif

#endif // (defined __E2ROM_MODULE) && (_MODULE_ON == __E2ROM_MODULE)

/***** sFLASH Module **********************************************************/
#if (defined __sFLASH_MODULE) && (_MODULE_ON == __sFLASH_MODULE)

/**** Includes ****************************************************************/
#include <sFlashSpec.h>

#define   _sFLASH_ByteOrder             (_sFLASH_LittleEndian)
#define   _sFLASH_BUF_DECLARED          (_sFLASH_DECLARED)
#define   _sFLASH_BUF_SIZE              (4096ul)        // unit: byte, please make sure this number is multiple of 4
#define   _sFLASH_TYPE                  (_sFLASH_is_23K256)
#define   _sFLASH_INTERFACE             (_HSPI__FLASH)  // set the interface type
#define   __sFLASH_IO_Speed             (is_50MHz)

#if (_sFLASH_INTERFACE == _HSPI__FLASH)
  #define   _sFLASH_HSPI_Ch             (SPI1)          // you can choose 1..3 for SPI1..3
#elif (_sFLASH_INTERFACE == _PARA2_FLASH)
  #define   _sFLASH_ARRAY_MODE          (_HIGH_08_BITS) // Choose array mode!
#elif (_sFLASH_INTERFACE == _PARA1_FLASH)
  #define   _sFLASH_ARRAY_MODE          (_1ST_04_BITS) // Choose array mode!
#endif

//***** _sFLASH_1 Config ******************************************************/
#if (_sFLASH_INTERFACE == _SSPI__FLASH) || (_sFLASH_INTERFACE == _HSPI__FLASH)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_1)
#define   __sFLASH_1_MOSI_PIN_N         (io_Pin_08)
#define   __sFLASH_1_MISO_PORT_N        (io_Port_1)
#define   __sFLASH_1_MISO_PIN_N         (io_Pin_09)
#define   __sFLASH_1_WP_PORT_N          (io_Port_1)
#define   __sFLASH_1_WP_PIN_N           (io_Pin_10)
#define   __sFLASH_1_HOLD_PORT_N        (io_Port_1)
#define   __sFLASH_1_HOLD_PIN_N         (io_Pin_11)
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)
#define   __sFLASH_1_CS_PIN_N           (io_Pin_00)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_0)
#define   __sFLASH_1_SCK_PIN_N          (io_Pin_15)
#endif // (_sFLASH_INTERFACE == _SSPI__FLASH)

#if (_PARA4_FLASH == _sFLASH_INTERFACE)
#define   _sFLASH_1_MOSI_PORT_BASE      (io_Port_1)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   _sFLASH_1_MOSI_PIN_NUM        (0U)            // IO0
#define   _sFLASH_1_MISO_PORT_BASE      (__sFLASH_1_MOSI_PORT_N)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   _sFLASH_1_MISO_PIN_NUM        (1U)            // IO1
#define   _sFLASH_1_WP_PORT_BASE        (__sFLASH_1_MOSI_PORT_N)    // WP
#define   _sFLASH_1_WP_PIN_NUM          (2U)            // IO2
#define   _sFLASH_1_HOLD_PORT_BASE      (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   _sFLASH_1_HOLD_PIN_NUM        (3U)            // IO3
#define   _sFLASH_1_CS_PORT_BASE        (io_Port_1)    // CS /*A*/
#define   _sFLASH_1_CS_PIN_NUM          (7U)
#define   _sFLASH_1_SCK_PORT_BASE       (io_Port_1)    // SCK
#define   _sFLASH_1_SCK_PIN_NUM         (6U)
#endif

#if (_LOW_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)
#define   _sFLASH_1_GPIO_SPEED          (GPIO_Speed_50MHz)
#define   _sFLASH_1_MOSI_PORT_BASE      (io_Port_1)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   _sFLASH_1_MOSI_PIN_NUM        (io_Pin_08)            // IO0
#define   _sFLASH_1_MISO_PORT_BASE      (__sFLASH_1_MOSI_PORT_N)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   _sFLASH_1_MISO_PIN_NUM        (io_Pin_09)            // IO1
#define   _sFLASH_1_WP_PORT_BASE        (__sFLASH_1_MOSI_PORT_N)    // WP
#define   _sFLASH_1_WP_PIN_NUM          (io_Pin_10)            // IO2
#define   _sFLASH_1_HOLD_PORT_BASE      (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   _sFLASH_1_HOLD_PIN_NUM        (io_Pin_11)            // IO3
#define   _sFLASH_1_CS_PORT_BASE        (io_Pin_00)    // CS /*A*/
#define   _sFLASH_1_CS_PIN_NUM          (io_Pin_00)
#define   _sFLASH_1_SCK_PORT_BASE       (io_Pin_03)    // SCK
#define   _sFLASH_1_SCK_PIN_NUM         (io_Pin_15)
#endif // (_LOW_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)

#if (_HIGH_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_1)     // please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MOSI_PIN_N         (io_Pin_08)     // IO0
#define   __sFLASH_1_MISO_PORT_N        (__sFLASH_1_MOSI_PORT_N)
#define   __sFLASH_1_MISO_PIN_N         (io_Pin_09)     // IO1
#define   __sFLASH_1_WP_PORT_N          (__sFLASH_1_MOSI_PORT_N)
#define   __sFLASH_1_WP_PIN_N           (io_Pin_10)     // IO2
#define   __sFLASH_1_HOLD_PORT_N        (__sFLASH_1_MOSI_PORT_N)
#define   __sFLASH_1_HOLD_PIN_N         (io_Pin_11)     // IO3
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)     // CS
#define   __sFLASH_1_CS_PIN_N           (io_Pin_00)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_0)     // SCK
#define   __sFLASH_1_SCK_PIN_N          (io_Pin_15)
#endif // (_sFLASH_INTERFACE == _SSPI__FY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)

#if (_sFLASH_INTERFACE == _PARA1_FLASH)
#if (_1ST_04_BITS == _sFLASH_ARRAY_MODE)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_3)    // please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MOSI_PIN_N         (0U)            // IO0
#define   __sFLASH_1_MISO_PORT_N        (__sFLASH_1_MOSI_PORT_N)    //  please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MISO_PIN_N         (1U)            // IO1
#define   __sFLASH_1_WP_PORT_N          (__sFLASH_1_MOSI_PORT_N)    // WP
#define   __sFLASH_1_WP_PIN_N           (2U)            // IO2
#define   __sFLASH_1_HOLD_PORT_N        (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   __sFLASH_1_HOLD_PIN_N         (3U)            // IO3
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)    // CS /*A*/
#define   __sFLASH_1_CS_PIN_N           (7U)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_1_SCK_PIN_N          (6U)
#elif (_2ND_04_BITS == _sFLASH_ARRAY_MODE)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_3)    // please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MOSI_PIN_N         (4U)            // IO0
#define   __sFLASH_1_MISO_PORT_N        (__sFLASH_1_MOSI_PORT_N)    //  please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MISO_PIN_N         (5U)            // IO1
#define   __sFLASH_1_WP_PORT_N          (__sFLASH_1_MOSI_PORT_N)    // WP
#define   __sFLASH_1_WP_PIN_N           (6U)            // IO2
#define   __sFLASH_1_HOLD_PORT_N        (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   __sFLASH_1_HOLD_PIN_N         (7U)            // IO3
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)    // CS /*A*/
#define   __sFLASH_1_CS_PIN_N           (12U)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_1_SCK_PIN_N          (15U)
#elif (_3RD_04_BITS == _sFLASH_ARRAY_MODE)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_3)    // please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MOSI_PIN_N         (8U)            // IO0
#define   __sFLASH_1_MISO_PORT_N        (__sFLASH_1_MOSI_PORT_N)    //  please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MISO_PIN_N         (9U)            // IO1
#define   __sFLASH_1_WP_PORT_N          (__sFLASH_1_MOSI_PORT_N)    // WP
#define   __sFLASH_1_WP_PIN_N           (10U)           // IO2
#define   __sFLASH_1_HOLD_PORT_N        (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   __sFLASH_1_HOLD_PIN_N         (11U)           // IO3
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)    // CS /*A*/
#define   __sFLASH_1_CS_PIN_N           (5U)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_1_SCK_PIN_N          (2U)
#elif (_4TH_04_BITS == _sFLASH_ARRAY_MODE)
#define   __sFLASH_1_MOSI_PORT_N        (io_Port_3)    // please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MOSI_PIN_N         (12U)            // IO0
#define   __sFLASH_1_MISO_PORT_N        (__sFLASH_1_MOSI_PORT_N)    //  please make sure the MOSI、 MISO、WP、HOLD is on the same PORT
#define   __sFLASH_1_MISO_PIN_N         (13U)            // IO1
#define   __sFLASH_1_WP_PORT_N          (__sFLASH_1_MOSI_PORT_N)    // WP
#define   __sFLASH_1_WP_PIN_N           (14U)            // IO2
#define   __sFLASH_1_HOLD_PORT_N        (__sFLASH_1_MOSI_PORT_N)    // HOLD
#define   __sFLASH_1_HOLD_PIN_N         (15U)            // IO3
#define   __sFLASH_1_CS_PORT_N          (io_Port_3)    // CS /*A*/
#define   __sFLASH_1_CS_PIN_N           (10U)
#define   __sFLASH_1_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_1_SCK_PIN_N          (8U)
#endif // (_1ST_04_BITS == _sFLASH_ARRAY_MODE)

#endif // (_sFLASH_INTERFACE == _PARA1_FLASH)
//***** _sFLASH_1 Config ******************************************************/

//***** _sFLASH_2 Config ******************************************************/
#if (_PARA4_FLASH == _sFLASH_INTERFACE)
#define   __sFLASH_2_MOSI_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_2_MOSI_PIN_N         (4U)            // IO0
#define   __sFLASH_2_MISO_PORT_N        (__sFLASH_2_MOSI_PORT_N)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_2_MISO_PIN_N         (5U)            // IO1
#define   __sFLASH_2_WP_PORT_N          (__sFLASH_2_MOSI_PORT_N)    // WP
#define   __sFLASH_2_WP_PIN_N           (6U)            // IO2
#define   __sFLASH_2_HOLD_PORT_N        (__sFLASH_2_MOSI_PORT_N)    // HOLD
#define   __sFLASH_2_HOLD_PIN_N         (7U)            // IO3
#define   __sFLASH_2_CS_PORT_N          (io_Port_3)    // CS
#define   __sFLASH_2_CS_PIN_N           (12U)
#define   __sFLASH_2_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_2_SCK_PIN_N          (15U)
#endif // (_PARA4_FLASH == _sFLASH_INTERFACE)

#if (_LOW_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)
#define   __sFLASH_2_MOSI_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_2_MOSI_PIN_N         (4U)            // IO0
#define   __sFLASH_2_MISO_PORT_N        (__sFLASH_2_MOSI_PORT_N) 
#define   __sFLASH_2_MISO_PIN_N         (5U)            // IO1
#define   __sFLASH_2_WP_PORT_N          (__sFLASH_2_MOSI_PORT_N)
#define   __sFLASH_2_WP_PIN_N           (6U)            // IO2
#define   __sFLASH_2_HOLD_PORT_N        (__sFLASH_2_MOSI_PORT_N)
#define   __sFLASH_2_HOLD_PIN_N         (7U)            // IO3
#define   __sFLASH_2_CS_PORT_N          (io_Port_3)    // CS
#define   __sFLASH_2_CS_PIN_N           (12U)
#define   __sFLASH_2_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_2_SCK_PIN_N          (15U)
#endif // (_LOW_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)

#if (_HIGH_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)
#define   __sFLASH_2_MOSI_PORT_N        (io_Port_1)
#define   __sFLASH_2_MOSI_PIN_N         (io_Pin_12)     // IO0
#define   __sFLASH_2_MISO_PORT_N        (__sFLASH_2_MOSI_PORT_N)
#define   __sFLASH_2_MISO_PIN_N         (io_Pin_13)     // IO1
#define   __sFLASH_2_WP_PORT_N          (__sFLASH_2_MOSI_PORT_N)
#define   __sFLASH_2_WP_PIN_N           (io_Pin_14)     // IO2
#define   __sFLASH_2_HOLD_PORT_N        (__sFLASH_2_MOSI_PORT_N)
#define   __sFLASH_2_HOLD_PIN_N         (io_Pin_15)     // IO3
#define   __sFLASH_2_CS_PORT_N          (io_Port_3)     // CS
#define   __sFLASH_2_CS_PIN_N           (io_Pin_01)
#define   __sFLASH_2_SCK_PORT_N         (io_Port_0)     // SCK
#define   __sFLASH_2_SCK_PIN_N          (io_Pin_02)
#endif // (_HIGH_08_BITS == _sFLASH_ARRAY_MODE) && (_sFLASH_INTERFACE == _PARA2_FLASH)
//***** _sFLASH_2 Config ******************************************************/

#if (_PARA4_FLASH == _sFLASH_INTERFACE)
//***** _sFLASH_3 Config ******************************************************/
#define   __sFLASH_2_MOSI_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_2_MOSI_PIN_N         (8U)            // IO0
#define   __sFLASH_2_MISO_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_2_MISO_PIN_N         (9U)            // IO1
#define   __sFLASH_2_WP_PORT_N          (io_Port_3)    // WP
#define   __sFLASH_2_WP_PIN_N           (10U)           // IO2
#define   __sFLASH_2_HOLD_PORT_N        (io_Port_3)    // HOLD
#define   __sFLASH_2_HOLD_PIN_N         (11U)           // IO3
#define   __sFLASH_2_CS_PORT_N          (io_Port_3)    // CS
#define   __sFLASH_2_CS_PIN_N           (5U)
#define   __sFLASH_2_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_2_SCK_PIN_N          (2U)
//***** _sFLASH_3 Config ******************************************************/

//***** _sFLASH_4 Config ******************************************************/
#define   __sFLASH_4_MOSI_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_4_MOSI_PIN_N         (12U)           // IO0
#define   __sFLASH_4_MISO_PORT_N        (io_Port_3)    // 硬件设计时，请满足MOSI、 MISO、WP、HOLD在同一PORT上
#define   __sFLASH_4_MISO_PIN_N         (13U)           // IO1
#define   __sFLASH_4_WP_PORT_N          (io_Port_3)    // WP
#define   __sFLASH_4_WP_PIN_N           (14U)           // IO2
#define   __sFLASH_4_HOLD_PORT_N        (io_Port_3)    // HOLD
#define   __sFLASH_4_HOLD_PIN_N         (15U)           // IO3
#define   __sFLASH_4_CS_PORT_N          (io_Port_3)    // CS
#define   __sFLASH_4_CS_PIN_N           (10U)
#define   __sFLASH_4_SCK_PORT_N         (io_Port_3)    // SCK
#define   __sFLASH_4_SCK_PIN_N          (8U)
//***** _sFLASH_4 Config ******************************************************/
#endif // (_PARA4_FLASH == _sFLASH_INTERFACE)

#endif //(_MODULE_ON == __sFlash_MODULE)

/**** __RADIO_MODULE *********************************************************/
#if (defined __RADIO_MODULE) && (_MODULE_ON == __RADIO_MODULE)
#include <rfChipSpec.h>
#include <ksPeriphSpec.h>

#define     __RADIO_EXT_PA_USED            (_MODULE_ON)

#define     __RADIO_PARA_STORAGE           (_KS_RW_STORAGE)
#define     __RADIO_ADDR_FILTER            (_FILTER_BY_PROTOCOL)

#define     __RADIO_MODULE_VER             (0x02) // 0 :: normal, 1 :: new, 2 :: drAlarm
#if   (__MCU_TYPE == _MCU_IS_NRF51822)
#define     _RADIO_TYPE                    (_RADIO_is_NRF51822)
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     _RADIO_TYPE                    (_RADIO_is_NRF52832)
#else
#define     _RADIO_TYPE                    (_RADIO_is_NRF52832)
#endif

#if   (_RADIO_TYPE == _RADIO_is_CC1101)
#define     __RADIO_REG_FILE               _CC1101_REG_CFG_005 // */ _CC1121_REG_CFG_006
#define     __RADIO_OSC_FREQ               26000000 // */ 32000000    // Hz
#define     __RADIO_POWER_SETTING          (_CC1101_P10DB_433MHZ) // */ _CC1121_P15DB_433MHZ
#elif (_RADIO_TYPE == _RADIO_is_CC1121)
#define     __RADIO_REG_FILE               _CC1121_REG_CFG_005
#define     __RADIO_OSC_FREQ               (32000000ull) // Hz
#define     __RADIO_POWER_SETTING          _CC1121_P14DB_433MHZ
#elif (_RADIO_TYPE == _RADIO_is_SI4438)
#define     __RADIO_REG_FILE               _SI4438B1_REG_CFG_002
#define SILABS_RADIO_SI446X
#define     __RADIO_OSC_FREQ               32000000    // Hz
#define     __RADIO_POWER_SETTING          _CC1121_P15DB_433MHZ
#elif (_RADIO_TYPE == _RADIO_is_NRF51822)
#define     __RADIO_REG_FILE               _NRF51822_REG_CFG_001 // 3 for BLE
#define     __RADIO_OSC_FREQ               (16000000ull)    // Hz
#define     __RADIO_POWER_SETTING          _NRF51822_P04DB_2400MHZ
#define     __RADIO_RSSI_STATE             (_RADIO_ON)
#elif (_RADIO_is_NRF52832 == _RADIO_TYPE)
#define     __RADIO_REG_FILE               _NRF52832_REG_CFG_001
#define     __RADIO_OSC_FREQ               (32000000ull)    // 64000000 Hz
#define     __RADIO_POWER_SETTING          _NRF52832_P00DB_2400MHZ
#define     __RADIO_RSSI_STATE             (_RADIO_ON)
#elif (_RADIO_TYPE == _RADIO_is_EFR32BG1P2G4)
#ifdef __DAHAO
#define     __RADIO_REG_FILE               _EFR32BP2G4_REG_CFG_DAHAO
#else
#define     __RADIO_REG_FILE               _EFR32BP2G4_REG_CFG_002
#endif
#define     __RADIO_OSC_FREQ               HSE_VALUE
#define     __RADIO_POWER_SETTING          _NRF51822_P04DB_2400MHZ
#endif

#define     _RADIO_INTERFACE               (_RADIO_HSPI)      // set the interface type
#define     __RADIO_ASSERT_STRATEGY        (_RADIO_EXIT_ON_FAULT)
#define     __RADIO_SELFTEST               (_RF_SELFTEST_ON) // */ (_RF_SELFTEST_OFF)
#define     __RADIO_CHAN_NB                (0x02)

#if (_RADIO_HSPI == _RADIO_INTERFACE)
#define     _RADIO_HSPIn                   (2) // you can choose 1..3 for SPI1..3
#define     _RADIO_HSPI_PRESCALER          (_SPI_BR_Prescaler_2)
#endif

#define     __RADIO_SEND_PACKET_DBGx       // add x to disable the MACRO
#define     __RADIO_SEND_DBG_SW            (0)

#if   (__MCU_TYPE == _MCU_IS_STM32L1x)
#define     __RADIO_GPIO_SPEED             (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32F10x)
#define     __RADIO_GPIO_SPEED             (is_50MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __RADIO_GPIO_SPEED             (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#define     __RADIO_GPIO_SPEED             (is_10MHz)    // for efm32TGxx, meaningless
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define     __RADIO_GPIO_SPEED             (is_10MHz)    // for efm32TGxx, meaningless
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     __RADIO_GPIO_SPEED             (is_10MHz)    // for efm32TGxx, meaningless
#endif

#if   (__RADIO_EXT_PA_USED == _MODULE_ON)
#define     __RADIO_PA_PORT                (io_Port_0)   //  MOSI
#define     __RADIO_PA_PIN                 (io_Pin_23)
#define     __RADIO_LNA_PORT               (io_Port_0)   //  MOSI
#define     __RADIO_LNA_PIN                (io_Pin_22)
#endif

#if (0 == __RADIO_MODULE_VER)

#define     __RADIO_MOSI_PORT_N            (io_Port_0)   //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_07)
#define     __RADIO_MISO_PORT_N            (io_Port_0)   //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_06)
#define     __RADIO_SCK_PORT_N             (io_Port_0)   //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_05)

#define     __RADIO_CS_PORT_N              (io_Port_0)   //  CS
#define     __RADIO_CS_PIN_N               (io_Pin_02)
#define     __RADIO_GDO0_PORT_N            (io_Port_0)   //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_03)
#define     __RADIO_GDO2_PORT_N            (io_Port_0)   //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_04)
#define     __RADIO_PWR_PORT_N             _GPIO_Port_1  //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_05)

#elif (2 == __RADIO_MODULE_VER) // drAlram
#if   ((__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32Gxxx))

#define     __RADIO_MOSI_PORT_N            (io_Port_4)   //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_11)
#define     __RADIO_MISO_PORT_N            (io_Port_4)   //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_10)
#define     __RADIO_SCK_PORT_N             (io_Port_4)   //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_12)

#define     __RADIO_CS_PORT_N              (io_Port_5)   //  CS
#define     __RADIO_CS_PIN_N               (io_Pin_02)

#define     __RADIO_GDO0_PORT_N            (io_Port_4) // */ _GPIO_NoPort   //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_13)
#define     __RADIO_GDO1_PORT_N            /* (io_Port_0)  // */ (io_Port_No)   //  GDO1
#define     __RADIO_GDO1_PIN_N             (io_Pin_00)
#define     __RADIO_GDO2_PORT_N            (io_Port_0) // */  _GPIO_NoPort  //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_00)
#define     __RADIO_GDO3_PORT_N            /* (io_Port_0)  // */ (io_Port_No) //  GDO3
#define     __RADIO_GDO3_PIN_N             (io_Pin_01)

#define     __RADIO_PWR_PORT_N             /* (io_Port_No) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_15)

#define     __RADIO_IRQ_PORT_N             /* (io_Port_1) // */ _GPIO_NoPort  //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_IRQ_PIN_N              (io_Pin_00)

#define     __RADIO_SHDN_PORT_N            /* (io_Port_0) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_SHDN_PIN_N             (io_Pin_08)

#define     __RADIO_RST_PORT_N             /* (io_Port_4) // */ _GPIO_NoPort // */    //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_RST_PIN_N              (io_Pin_13)

#elif (__MCU_TYPE == _MCU_IS_STM32L0x)

#define     __RADIO_MOSI_PORT_N            (io_Port_1)   //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_15)
#define     __RADIO_MISO_PORT_N            (io_Port_1)   //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_14)
#define     __RADIO_SCK_PORT_N             (io_Port_1)   //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_13)

#define     __RADIO_CS_PORT_N              (io_Port_1)   //  CS
#define     __RADIO_CS_PIN_N               (io_Pin_12)

#define     __RADIO_GDO0_PORT_N            (io_Port_1)   // */ _GPIO_NoPort    //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_11)   // */ (io_Pin_01)
#define     __RADIO_GDO1_PORT_N            /* (io_Port_0)  // */ (io_Port_No)   //  GDO1
#define     __RADIO_GDO1_PIN_N             (io_Pin_00)
#define     __RADIO_GDO2_PORT_N            (io_Port_0)   // */  _GPIO_NoPort   //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_08)   // */ (io_Pin_03)
#define     __RADIO_GDO3_PORT_N            /* (io_Port_0)  // */ (io_Port_No)   //  GDO3
#define     __RADIO_GDO3_PIN_N             (io_Pin_01)

#define     __RADIO_PWR_PORT_N             /* (io_Port_No) // */ _GPIO_NoPort   //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_15)

#define     __RADIO_IRQ_PORT_N             /* (io_Port_1) // */ _GPIO_NoPort   //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_IRQ_PIN_N              (io_Pin_00)

#define     __RADIO_SHDN_PORT_N            /* (io_Port_0) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_SHDN_PIN_N             (io_Pin_08)

#define     __RADIO_RST_PORT_N             (io_Port_0) // */ _GPIO_NoPort // */    //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_RST_PIN_N              (io_Pin_04)

#endif

#elif (1 == __RADIO_MODULE_VER)
#if   (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __RADIO_MOSI_PORT_N            (io_Port_0)   //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_07)
#define     __RADIO_MISO_PORT_N            (io_Port_0)   //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_06)
#define     __RADIO_SCK_PORT_N             (io_Port_0)   //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_05)

#define     __RADIO_CS_PORT_N              (io_Port_0)   //  CS
#define     __RADIO_CS_PIN_N               (io_Pin_03)

#define     __RADIO_GDO0_PORT_N            /* _GPIO_NoPort // */ (io_Port_0)   //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_02)
#define     __RADIO_GDO1_PORT_N            /* (io_Port_0)  // */ (io_Port_No)   //  GDO1
#define     __RADIO_GDO1_PIN_N             (io_Pin_00)
#define     __RADIO_GDO2_PORT_N            /* _GPIO_NoPort // */ (io_Port_0)   //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_04)
#define     __RADIO_GDO3_PORT_N            /* (io_Port_0)  // */ (io_Port_No) //  GDO3
#define     __RADIO_GDO3_PIN_N             (io_Pin_01)

#define     __RADIO_PWR_PORT_N             _GPIO_NoPort // */ _GPIO_Port_0 //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_15)

#define     __RADIO_IRQ_PORT_N             (io_Port_1) // */ _GPIO_NoPort  //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_IRQ_PIN_N              (io_Pin_00)

#define     __RADIO_SHDN_PORT_N            (io_Port_0) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_SHDN_PIN_N             (io_Pin_08)

#define     __RADIO_RST_PORT_N             /* _GPIO_NoPort // */ (io_Port_1)   //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_RST_PIN_N              (io_Pin_12)
#elif ((__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32Gxxx))
#define     __RADIO_MOSI_PORT_N            (io_Port_4)   //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_10)
#define     __RADIO_MISO_PORT_N            (io_Port_4)   //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_11)
#define     __RADIO_SCK_PORT_N             (io_Port_4)   //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_12)

#define     __RADIO_CS_PORT_N              (io_Port_4)   //  CS
#define     __RADIO_CS_PIN_N               (io_Pin_13)

#define     __RADIO_GDO0_PORT_N            (io_Port_2) // */ _GPIO_NoPort   //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_14)
#define     __RADIO_GDO1_PORT_N            /* (io_Port_0)  // */ (io_Port_No)   //  GDO1
#define     __RADIO_GDO1_PIN_N             (io_Pin_00)
#define     __RADIO_GDO2_PORT_N            (io_Port_1) // */  _GPIO_NoPort  //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_11)
#define     __RADIO_GDO3_PORT_N            /* (io_Port_0)  // */ (io_Port_No) //  GDO3
#define     __RADIO_GDO3_PIN_N             (io_Pin_01)

#define     __RADIO_PWR_PORT_N             /* (io_Port_No) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_15)

#define     __RADIO_IRQ_PORT_N             /* (io_Port_1) // */ _GPIO_NoPort  //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_IRQ_PIN_N              (io_Pin_00)

#define     __RADIO_SHDN_PORT_N            /* (io_Port_0) // */ _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_SHDN_PIN_N             (io_Pin_08)

#define     __RADIO_RST_PORT_N             /* (io_Port_4) // */ _GPIO_NoPort // */    //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_RST_PIN_N              (io_Pin_13)
#endif

#elif (2 == __RADIO_MODULE_VER)
#define     __RADIO_GPIO_SPEED             (is_50MHz)
#define     __RADIO_MOSI_PORT_N            (io_Port_0) //  MOSI
#define     __RADIO_MOSI_PIN_N             (io_Pin_07)
#define     __RADIO_MISO_PORT_N            (io_Port_0) //  MISO
#define     __RADIO_MISO_PIN_N             (io_Pin_06)
#define     __RADIO_SCK_PORT_N             (io_Port_0) //  SCK
#define     __RADIO_SCK_PIN_N              (io_Pin_05)

#define     __RADIO_CS_PORT_N              (io_Port_1) //  CS  // A2
#define     __RADIO_CS_PIN_N               (io_Pin_00)

#define     __RADIO_GDO0_PORT_N            (io_Port_0) //  GDO0
#define     __RADIO_GDO0_PIN_N             (io_Pin_03)
#define     __RADIO_GDO1_PORT_N            (io_Port_No) //  GDO1
#define     __RADIO_GDO1_PIN_N             (io_Pin_03)
#define     __RADIO_GDO2_PORT_N            (io_Port_0) //  GDO2
#define     __RADIO_GDO2_PIN_N             (io_Pin_04)
#define     __RADIO_GDO3_PORT_N            (io_Port_No) //  GDO3
#define     __RADIO_GDO3_PIN_N             (io_Pin_04)
#define     __RADIO_PWR_PORT_N             _GPIO_NoPort //  pwrIO, make sure the argument is a macro!!
#define     __RADIO_PWR_PIN_N              (io_Pin_15)

#endif
/***** NVIC Configuration *****************************************************/
//extern void MRFI_GpioIsr(void);
extern void CC110x_Sniffer_ISR(void);
#define     __RADIO_TRx_IRQ_ROUTINE        /* (CC110x_Sniffer_ISR) // */ NULL
#define     __RADIO_TRx_IRQ_PIN            /* (_RADIO_GDO3) // */ (_RADIO_GDO2)
#define     __RADIO_TRx_IRQ_PrePrio        (2u)
#define     __RADIO_TRx_IRQ_SubPrio        (0u)

#define     __RADIO_PQT_IRQ_PIN            (_RADIO_GDO0) // not an ISR
#define     __RADIO_PQT_IRQ_PrePrio        (2u)
#define     __RADIO_PQT_IRQ_SubPrio        (2u)

#endif //   (_MODULE_ON == __RADIO_MODULE)

/***** IR Module **************************************************************/
#if (defined __IR_MODULE) && (_MODULE_ON == __IR_MODULE)

/**** Defines *****************************************************************/
#define     __IR_DEBUGSTATUS            (_IR_DEBUG_ON)
#define     __IR_DISP_RAW_DATA          (false)
#define     __IR_DISP_DEMODULATED_DATA  (true)
#define     __IR_DISP_ZIPED_DATA        (true)

#if (defined _sFLASH_BUF_DECLARED)  && \
    (defined _sFLASH_DECLARED)      && \
    (_sFLASH_DECLARED == _sFLASH_BUF_DECLARED)
/**** Unit: byte, the value should be multiply of 4 ***************************/
#define     IR_BUF_SIZE                 (_sFLASH_BUF_SIZE)
#else
#define     IR_BUF_SIZE                 (4096)
#endif

/**** IR data in GPIO *********************************************************/
#define     __IR_DATA_IN_PORT_N         (io_Port_1)
#define     __IR_DATA_IN_PIN_N          (io_Pin_06)
#define     __IR_DATA_IN_SPEED          (is_50MHz)
#define     __IR_DATA_IN_MODE           (io_Mode_IPU)

/**** IR data out GPIO ********************************************************/
#define     __IR_DATA_OUT_PORT_N        (io_Port_1)
#define     __IR_DATA_OUT_PIN_N         (io_Pin_05)
#define     __IR_DATA_OUT_SPEED         (is_50MHz)
#define     __IR_DATA_OUT_MODE          (io_Mode_APP)
#define     __IR_OUT_OCn_CHAN           (2)

/**** IR Timer ****************************************************************/
// please make sure this para matches with the IR_DATA_OUT_PIN
#define     __IR_PWM_TIMER_N            (is_tim03)
#define     __IR_TRANCEIVER_TIMER_N     (is_tim02)
#define     __IR_PWM_FREQ               (38000u)// IR PWM Frequency, unit: Hz
#define     __IR_PWM_DUTYCYCLE          (10u)   // IR PWM Dutycycle, unit %

/**** IR Data Buffer Configuration ********************************************/
#define     __IR_BUF_TYPE               (_IR_BUF_is_sFLASH)
#define     __IR_BUF_MODE               (_sFLASH_INTERFACE)
#define     __IR_BUF_START_SECTOR       (0x0000u) // the sector is numbered based on one sFlash
#define     __IR_BUF_STAGING_SIZE       (0x04)    // howmany sector units
/**** The parameters concerning the IR DATA buf is mostly derived from sFlash */

/**** IR NVIC *****************************************************************/
#define     __IR_IRQ_PrePrio            (0)
#define     __IR_IRQ_SubPrio            (0)

#define     IR_TRASMIT_STATUS           (_IR_IN)

#define     _LEARN_IR_DATA              (0)
#define     _USE_IR_DATA                (1)
#define     _WORKING_STATUS             (_USE_IR_DATA)

#define     _BOARD_WITH_sFlash          (0)
#define     _BOARD_WITHOUT_sFlash       (1)
#define     _BOARD_STATUS               (_BOARD_WITH_sFlash)

#endif  //  ((_MODULE_ON == __IR_MODULE) && (defined (_USE_GLOBAL_PROJECT_CONFIGURATION)))

/***** SMPL Module ************************************************************/
#if (_MODULE_ON == __SMPL120_MODULE)
/**** Includes ****************************************************************/

/**** Defines *****************************************************************/
#define     MRFI_CC1101
#define     __SMPL_FUNCTION         (_SMPL_LINKTO)
#define     __SMPL_DEV_TYPE         (_END_DEV)

#if     (__SMPL_DEV_TYPE == _END_DEV)
/*******************************************************************************
 * Number of connections supported. each connection supports bi#define irectional
 * communication.  Access Points and Range Extenders can set this to 0 if they
 * do not host End Device objects
*******************************************************************************/
#define     NUM_CONNECTIONS         2

/***** Size of low-lvl queues for sent and received frames. Affects RAM usage */

/*******************************************************************************
 * AP needs larger input frame queue if it is supporting store-and-forward
 * clients because the forwarded messages are held here. Two is probably enough
 * for an End Device
*******************************************************************************/
#define     SIZE_INFRAME_Q          7

/*******************************************************************************
 * The output frame queue can be small since Tx is done synchronously. Actually
 * 1 is probably enough. If an Access Point device is also hosting an End Device
 * that sends to a sleeping peer the output queue should be larger -- the waiting
 * frames in this case are held here. In that case the output frame queue should
 * be bigger.
*******************************************************************************/
#define     SIZE_OUTFRAME_Q         2

/*******************************************************************************
 * This device's address. The first byte is used as a filter on the CC1100/CC2500
 * radios so THE FIRST BYTE MUST NOT BE either 0x00 or 0xFF. Also, for these radios
 * on End Devices the first byte should be the least significant byte so the filtering
 * is maximally effective. Otherwise the frame has to be processed by the MCU before it
 * is recognized as not intended for the device. APs and REs run in promiscuous mode so
 * the filtering is not done. This macro intializes a static const array of unsigned
 * characters of length NET_ADDR_SIZE (found in nwk_types.h). the quotes (") are
 * necessary below unless the spaces are removed.
*******************************************************************************/
#define THIS_DEVICE_ADDRESS     {0x02,0x02} // {0x79, 0x56, 0x34, 0x12}
#define THIS_DEVICE_NETHASH     {0x7b} // {0x79, 0x56, 0x34, 0x12}
#define THIS_DEVICE_NETID       {0x00,0x00,0x01,0x23,0x46} // {0x79, 0x56, 0x34, 0x12}

#define MAX_HOPS                2 // max hop count -DMAX_HOPS=2

/*******************************************************************************
 * max hops away from and AP. Keeps hop count and therefore replay
 * storms down for sending to and from polling End Devices. Also used
 * when joining since the EDs can't be more than 1 hop away.
*******************************************************************************/
#define MAX_HOPS_FROM_AP        1 // -DMAX_HOPS_FROM_AP=1

/*******************************************************************************
 * Maximum size of Network application payload. Do not change unless
 * protocol changes are reflected in different maximum network
 * application payload size.
*******************************************************************************/
#define MAX_NWK_PAYLOAD         9 // -DMAX_NWK_PAYLOAD=9
#define MAX_APP_PAYLOAD         36 /* Maximum size of application payload */
#define DEFAULT_LINK_TOKEN      0x01020304 /* default Link token */
#define DEFAULT_JOIN_TOKEN      0x05060708 /* default Join token */
#define xFREQUENCY_AGILITY      // Remove 'x' to define Freq Agility as active for this build
#define APP_AUTO_ACK            // Remove 'x' to enable app autoacknowledge. Requires extended API
#define EXTENDED_API            // Remove 'x' to enable Extended API
#define xSMPL_SECURE            // Remove 'x' to enable security.
#define xNVOBJECT_SUPPORT       // Remove 'x' to enable NV object support.
#define xSW_TIMER               // Remove 'x' to enable software timer.
#define xFREQUENCY_HOPPING      // Remove 'x' to enable frequency hopping.
#define BSP_TIMER_USED          BSP_TIMER_A3
#define xNWK_PLL_REFERENCE_CLOCK // Remove 'x' to make this device the reference clock.
/* causes leds to blink in 00 -> 01 -> 11 -> 10 -> 00 rotation when FHSS enabled */
#define NWK_PLL_SHOW_LOCATION_INDICATORS

/***** device type ************************************************************/
#define END_DEVICE

/*******************************************************************************
 * For polling End Devices we need to specify that they do so. Uncomment the
 * macro definition below if this is a polling device. This field is used
 * by the Access Point to know whether to reserve store-and-forward support
 * for the polling End Device during the Join exchange.
*******************************************************************************/
/* #define RX_POLLS */

#elif   (__SMPL_DEV_TYPE == _ACCESS_POINT)

#define     NUM_CONNECTIONS         2
#define     SIZE_INFRAME_Q          10
#define     SIZE_OUTFRAME_Q         4
#define     THIS_DEVICE_ADDRESS     {0x78,0x56} // {0x79, 0x56, 0x34, 0x12}
#define     THIS_DEVICE_NETHASH     {0x7b} // {0x79, 0x56, 0x34, 0x12}
#define     THIS_DEVICE_NETID       {0x00,0x00,0x01,0x23,0x46} // {0x79, 0x56, 0x34, 0x12}

#define     MAX_HOPS                2 // max hop count -DMAX_HOPS=2
#define     MAX_HOPS_FROM_AP        1 // -DMAX_HOPS_FROM_AP=1

#define     MAX_NWK_PAYLOAD         9 // -DMAX_NWK_PAYLOAD=9
#define     MAX_APP_PAYLOAD         36 /* Maximum size of application payload */
#define     DEFAULT_LINK_TOKEN      0x01020304 /* default Link token */
#define     DEFAULT_JOIN_TOKEN      0x05060708 /* default Join token */
#define     xFREQUENCY_AGILITY      // Remove 'x' to define Freq Agility as active for this build
#define     APP_AUTO_ACK            // Remove 'x' to enable app autoacknowledge. Requires extended API
#define     EXTENDED_API            // Remove 'x' to enable Extended API
#define     xSMPL_SECURE            // Remove 'x' to enable security.
#define     xNVOBJECT_SUPPORT       // Remove 'x' to enable NV object support.
#define     xSW_TIMER               // Remove 'x' to enable software timer.
#define     xFREQUENCY_HOPPING      // Remove 'x' to enable frequency hopping.
#define     BSP_TIMER_USED          BSP_TIMER_A3
#define     xNWK_PLL_REFERENCE_CLOCK // Remove 'x' to make this device the reference clock.
/* causes leds to blink in 00 -> 01 -> 11 -> 10 -> 00 rotation when FHSS enabled */
#define     NWK_PLL_SHOW_LOCATION_INDICATORS

/***** device type ************************************************************/
#define     ACCESS_POINT

/* In the spcial case in which the AP is a data hub, the AP will automaically
 * listen for a link each time a new device joins the network. This is a special
 * case scenario in which all End Device peers are the AP and every ED links
 * to the AP. In this scenario the ED must automatically try and link after the
 * Join reply.
 */
#define     xAP_IS_DATA_HUB

/* Store and forward support: number of clients */
#define     NUM_STORE_AND_FWD_CLIENTS   3

#define     STARTUP_JOINCONTEXT_ON

/*******************************************************************************
 * For polling End Devices we need to specify that they do so. Uncomment the
 * macro definition below if this is a polling device. This field is used
 * by the Access Point to know whether to reserve store-and-forward support
 * for the polling End Device during the Join exchange.
*******************************************************************************/
/* #define RX_POLLS */

#elif   (__SMPL_DEV_TYPE == _REPEATER)
#else
#error wrong device type, please check!!
#endif

#endif // (_MODULE_ON == __SMPL120_MODULE)

/***** LwIP Module ************************************************************/
#if (defined __LWIP_MODULE) &&(_MODULE_ON == __LWIP_MODULE)

#if (defined __ETHCTRL_MODULE) && (__ETHCTRL_MODULE == _MODULE_ON)

/**** Includes ****************************************************************/
#include <ethCtrlSpec.h>

/**** Defines *****************************************************************/
#define   __ETHCTRL_TYPE                   _ETHCTRL_is_ENC28J60

#define   __ETHCTRL_TIMER_BUS              (__KS_TIMER_002)
#define   __ETHCTRL_TIM_SHORT_INTERVAL     (10000ul)   // us
#define   __ETHCTRL_TIM_LONG_INTERVAL      (125000ull) // us
#define   __ETHCTRL_TIM_NUMERATOR          (1)
#define   __ETHCTRL_TIM_DENOMINATOR        (4)

#define   __ETHCTRL_TIMER_PRIPRIO          (1) // make sure the timer isr has the highest priority next to voice control timer isr
#define   __ETHCTRL_TIMER_SUBPRIO          (0)

#if   (__ETHCTRL_TYPE == _ETHCTRL_is_ENC28J60)
#define   __ETHCTRL_INTERFACE               _ETHCTRL_HSPI

#if (_ETHCTRL_HSPI == __ETHCTRL_INTERFACE)
#define     _ETHCTRL_HSPIn                  (1) // you can choose 1..3 for SPI1..3
#define     _ETHCTRL_HSPI_PRESCALER         (_SPI_BR_Prescaler_8)
#endif

#if   (__MCU_TYPE == _MCU_IS_STM32F10x)
#define   __ETHCTRL_MOSI_PORT               (io_Port_A)     // TXD || MOSI
#define   __ETHCTRL_MOSI_PIN                (io_Pin_07)     // TXD || MOSI

#define   __ETHCTRL_MISO_PORT               (io_Port_A)     // RXD || MISO
#define   __ETHCTRL_MISO_PIN                (io_Pin_06)     // RXD || MISO

#define   __ETHCTRL_SCK_PORT                (io_Port_A)     // for spi use
#define   __ETHCTRL_SCK_PIN                 (io_Pin_05)     // for spi use

#define   __ETHCTRL_CS_PORT                 (io_Port_A)     // for spi use
#define   __ETHCTRL_CS_PIN                  (io_Pin_04)     // for spi use

#define   __ETHCTRL_IRQ_PORT                (io_Port_B)     // for spi use
#define   __ETHCTRL_IRQ_PIN                 (io_Pin_07)     // for spi use

#define   __ETHCTRL_RST_PORT                (_GPIO_NoPort)  // (io_Port_B)     // for spi use
#define   __ETHCTRL_RST_PIN                 (io_Pin_08)     // for spi use

extern void GPIOTE_IRQHandler (void);
#define   __ETHCTRL_PKT_IRQ_CALLBACK        NULL
#elif (__MCU_TYPE == _MCU_IS_NRF52832)

#define   __ETHCTRL_MOSI_PORT               (io_Port_0)     // TXD || MOSI
#define   __ETHCTRL_MOSI_PIN                (io_Pin_13)     // TXD || MOSI

#define   __ETHCTRL_MISO_PORT               (io_Port_0)     // RXD || MISO
#define   __ETHCTRL_MISO_PIN                (io_Pin_14)     // RXD || MISO

#define   __ETHCTRL_SCK_PORT                (io_Port_0)     // for spi use
#define   __ETHCTRL_SCK_PIN                 (io_Pin_12)     // for spi use

#define   __ETHCTRL_CS_PORT                 (io_Port_0)     // for spi use
#define   __ETHCTRL_CS_PIN                  (io_Pin_15)     // for spi use

#define   __ETHCTRL_IRQ_PORT                (io_Port_0)     // for spi use
#define   __ETHCTRL_IRQ_PIN                 (io_Pin_16)     // for spi use

#define   __ETHCTRL_RST_PORT                (io_Port_0) // */ _GPIO_NoPort     // for spi use
#define   __ETHCTRL_RST_PIN                 (io_Pin_11)     // for spi use

extern void GPIOTE_IRQHandler (void);
#define   __ETHCTRL_PKT_IRQ_CALLBACK        GPIOTE_IRQHandler

#endif

#else
#error "please specify the __ETHCTRL_TYPE"
#endif

#else
#warning "please switch on the __ETHCTRL_MODULE."
#endif // (__ETHCTRL_MODULE)

#define   __REVO_ETH_PRIPRIO                (2)
#define   __REVO_ETH_SUBPRIO                (0)

/**
 * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
 * critical regions during buffer allocation, deallocation and memory
 * allocation and deallocation.
 */
#define SYS_LIGHTWEIGHT_PROT                (0)

/**
 * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
 * use lwIP facilities.
 */
#define NO_SYS                              (1)

/**
 * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
 * Mainly for compatibility to old versions.
 */
#define NO_SYS_NO_TIMERS                    (1)

/* ---------- Memory options ---------- */
/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
   byte alignment -> define MEM_ALIGNMENT to 2. */
#define MEM_ALIGNMENT                       (4)

/* MEM_SIZE: the size of the heap memory. If the application will send
a lot of data that needs to be copied, this should be set high. */
#define MEM_SIZE                            (((16*1024ul)/MEM_ALIGNMENT)*MEM_ALIGNMENT)

/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
   sends a lot of data out of ROM (or other static memory), this
   should be set high. */
#define MEMP_NUM_PBUF                       (20)
/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One per
 * active UDP "connection". */
#define MEMP_NUM_UDP_PCB                    (1) // enough
/* MEMP_NUM_TCP_PCB: the number of simultaneously active TCP connections. */
#define MEMP_NUM_TCP_PCB                    (12) // enough
/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */
#define MEMP_NUM_TCP_PCB_LISTEN             (4) // enough
/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */
#define MEMP_NUM_TCP_SEG                    (64)
/* MEMP_NUM_SYS_TIMEOUT: the number of simultaneously active timeouts. */
#define MEMP_NUM_SYS_TIMEOUT                (3)

/* ---------- Pbuf options ---------- */
/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
#define PBUF_POOL_SIZE                      (20) // 10

/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
#define PBUF_POOL_BUFSIZE                   (220 + 64)

/***** TCP options ************************************************************/
#define LWIP_TCP                            (1)
#define TCP_TTL                             (255)

/***** Controls if TCP should queue segments that arrive out of
   order. Define to 0 if your device is low on memory. */
#define TCP_QUEUE_OOSEQ                     (1) // how about the memory!! 39242(off)

/***** TCP Maximum segment size. **********************************************/
#define TCP_MSS                             (220) // */ (1500 - 40), minus the packet header
/* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */

/***** TCP sender buffer space (bytes). ***************************************/
#define TCP_SND_BUF                         (8 * TCP_MSS)

/***** TCP sender buffer space (pbufs). This must be at least = 2 *
   TCP_SND_BUF/TCP_MSS for things to work. */
#define TCP_SND_QUEUELEN                    (8 * TCP_SND_BUF)/TCP_MSS

/**** TCP receive window. *****************************************************/
#define TCP_WND                             (1 * TCP_MSS) // */ (2 * TCP_MSS)

#define LWIP_TCP_KEEPALIVE                  (1)

/***** ICMP options ***********************************************************/
#define LWIP_ICMP                           (1)

/**** DHCP options ************************************************************/
/* Define LWIP_DHCP to 1 if you want DHCP configuration of
   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
   turning this on does currently not work. */
#define LWIP_DHCP                          (0)

/**** UDP options *************************************************************/
#define LWIP_UDP                            (1)
#define UDP_TTL                             (255)

/**** Statistics options ******************************************************/
#define LWIP_STATS                          (0)
#define LWIP_PROVIDE_ERRNO                  (1)
// ok

/**** Checksum options  *******************************************************/
/*
The STM32F107 allows computing and verifying the IP, UDP, TCP and ICMP checksums
 - by hardware:
 - To use this feature let the following define uncommented.
 - To disable it and process by CPU comment the the checksum.
*/
#if (__ETHCTRL_TYPE == _ETHCTRL_is_ENC28J60)
#define CHECKSUM_BY_HARDWAREx
#else
#define CHECKSUM_BY_HARDWARE
#endif

#ifdef CHECKSUM_BY_HARDWARE
  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
  #define CHECKSUM_GEN_IP                 0
  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
  #define CHECKSUM_GEN_UDP                0
  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
  #define CHECKSUM_GEN_TCP                0
  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
  #define CHECKSUM_CHECK_IP               0
  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
  #define CHECKSUM_CHECK_UDP              0
  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
  #define CHECKSUM_CHECK_TCP              0
#else
  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
  #define CHECKSUM_GEN_IP                 1
  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
  #define CHECKSUM_GEN_UDP                1
  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
  #define CHECKSUM_GEN_TCP                1
  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
  #define CHECKSUM_CHECK_IP               1
  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
  #define CHECKSUM_CHECK_UDP              1
  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
  #define CHECKSUM_CHECK_TCP              1
#endif

/**** Sequential layer options ************************************************/
/**** LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c) **********/
#define LWIP_NETCONN                      0

/**** Socket options **********************************************************/
/**** LWIP_SOCKET==1: Enable Socket API (require to use sockets.c) ************/
#define LWIP_SOCKET                       0

#define LWIP_DNS                          0

#endif // (defined __LWIP_MODULE) &&(_MODULE_ON == __LWIP_MODULE)


#if (defined __KSHCI_MODULE) && (__KSHCI_MODULE == _MODULE_ON)
#include <rvHciSpec.h>

#define     __RVCM_USE_HCI_INTERFACE
#define     _KSHCI_INTERFACE                (_RLHCI_HSPI)      // set the interface type

#if (_RFCHIP_HSPI == _RFCHIP_INTERFACE)
#define     _KSHCI_HSPIn                    (3) // you can choose 1..3 for SPI1..3
#define     __KSHCI_PRESCALER               (_SPI_BR_Prescaler_8) // */ (_SPI_BR_Prescaler_16)
#endif

#if   (__MCU_TYPE == _MCU_IS_STM32L1x)
#define     __KSHCI_IO_SPEED_N_1            (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32F10x)
#define     __KSHCI_IO_SPEED                (is_50MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __KSHCI_IO_SPEED                (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#define     __KSHCI_IO_SPEED                (is_10MHz)    // for efm32TGxx, meaningless
#endif

#define     __KSHCI_TX_PORT_N               (io_Port_B)     // TXD || MOSI
#define     __KSHCI_TX_PIN_N                (io_Pin_05)     // TXD || MOSI

#define     __KSHCI_RX_PORT_N               (io_Port_B)     // RXD || MISO
#define     __KSHCI_RX_PIN_N                (io_Pin_04)     // RXD || MISO

#define     __KSHCI_SCK_PORT_N              (io_Port_B)     // for spi use
#define     __KSHCI_SCK_PIN_N               (io_Pin_03)     // for spi use

#define     __KSHCI_CS_PORT_N               (io_Port_B)     // for spi use
#define     __KSHCI_CS_PIN_N                (io_Pin_06)     // for spi use

#define     __KSHCI_SYNC_PORT_N             (io_Port_B)     // for spi use
#define     __KSHCI_SYNC_PIN_N              (io_Pin_07)     // for spi use

#define     __KSHCI_RST_PORT_N              (io_Port_B)     // for spi use
#define     __KSHCI_RST_PIN_N               (io_Pin_08)     // for spi use

#define     __RV_PERIPH_LIB_USED

extern void rvHciDataPresentCallBack(void);
#define     __RFCHIP_DAT_IRQ_ROUTINE        (rvHciDataPresentCallBack) // */ NULL

#endif // (defined __KSHCI_MODULE) && (__KSHCI_MODULE == _MODULE_ON)

/************************* Tracer_Debugger_Module ******************************/
#if (defined __TRACER_MODULE) && (__TRACER_MODULE == _MODULE_ON)
#include <tracer_spec.h>

#ifndef __MCU_TYPE
#define     __MCU_TYPE                      (_MCU_IS_NRF51822)
#endif

#define     __USART_TRACER                  (_TRACER_ON)
#define     __SPI_TRACER                    (_TRACER_OFF)

#define     __TRACER_BUF_SIZE               (20)
#define     __TRACER_CONSOLE_SIZE           (50)
#define     __TRACER_PRINTF_STATUS          (_TRACER_ON)
#define     __TRACER_PRINTFBUF_SIZE         (128)
#define     __TRACER_DMABUF_SIZE            (256) // todo :: test
#define     __TRACER_CONSOLE                (_TRACER_0)
#define     __TRACER_OUT                    (__TRACER_CONSOLE)
#define     __sTRACER_CONSOLE               (_TRACER_0)

/**** Debugger IO Configuration ***********************************************/
#if (__USART_TRACER ==_TRACER_ON)
#define     __uTRACER_CNT                   (0x01)
#else
#define     __uTRACER_CNT                   (0x00)
#endif
#if (__SPI_TRACER ==_TRACER_ON)
#define     __sTRACER_CNT                   (0x01)
#else
#define     __sTRACER_CNT                   (0x00)
#endif

#if (__uTRACER_CNT >= 1)
#define     __UTRACER_IDX_1                 (0x00)

#define     __uTRACER_BDR_1                 (115200)        // Baud Rate
#define     __uTRACER_BUS_1                 (_USART_CHN_1)  // choose the channel
#define     __uTRACER_FLWCNTL               (_TRACER_OFF)

#define     __uTRACER_ISR_MODE_1            /* (_TRACER_ISR_DMA) // */ (_TRACER_ISR_NODMA)

#if   (__uTRACER_ISR_MODE_1 == _TRACER_ISR_NODMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __uTRACER_RCVISR_FLAG_1         (USART_IF_RXDATAV)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)   || \
       (__MCU_TYPE == _MCU_IS_STM32F10x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F4xx)  || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx)   || \
       (__MCU_TYPE == _MCU_IS_STM32L0x))
#define     __uTRACER_RCVISR_FLAG_1         (USART_IT_RXNE)
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define     __uTRACER_RCVISR_FLAG_1         (NRF_UART0_BASE + 0x108)  // (NRF_UART0->EVENTS_RXDRDY)
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     __uTRACER_RCVISR_FLAG_1         (NRF_UART0_BASE + 0x108)  // (NRF_UART0->EVENTS_RXDRDY)
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define     __uTRACER_RCVISR_FLAG_1         (USART_IF_RXDATAV)

#else
#endif

#elif   (__uTRACER_ISR_MODE_1 == _TRACER_ISR_DMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __uTRACER_RCVISR_FLAG_1         (USART_IT_IDLE)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)   || \
       (__MCU_TYPE == _MCU_IS_STM32F10x)  || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx)   || \
       (__MCU_TYPE == _MCU_IS_STM32L0x))
#define     __uTRACER_RCVISR_FLAG_1         (USART_IT_IDLE)
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define     __uTRACER_RCVISR_FLAG_1         (NRF_UART0_BASE + 0x108)  // (NRF_UART0->EVENTS_RXDRDY)
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     __uTRACER_RCVISR_FLAG_1         (NRF_UARTE0_BASE + 0x110)  // (NRF_UARTE0->EVENTS_ENDRX)
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define     __uTRACER_RCVISR_FLAG_1         (USART_IF_RXDATAV)
#else
#endif

#endif

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __uTRACER_TXISR_FLAG_1          (USART_IF_TXC)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)   || \
       (__MCU_TYPE == _MCU_IS_STM32F10x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F4xx)  || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx)   || \
       (__MCU_TYPE == _MCU_IS_STM32L0x))
#define     __uTRACER_TXISR_FLAG_1          (USART_IT_TC)
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define     __uTRACER_TXISR_FLAG_1          (NRF_UART0_BASE + 0x11C)  // (NRF_UART0->EVENTS_TXDRDY)
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     __uTRACER_TXISR_FLAG_1          (NRF_UARTE0_BASE + 0x120)  // (NRF_UARTE0->EVENTS_ENDTX)
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define     __uTRACER_TXISR_FLAG_1          (USART_IF_TXC)
#else
#endif

#define     __uTRACER_RX_PREPRIO_1          (2)
#define     __uTRACER_RX_SUBPRIO_1          (3)
#define     __uTRACER_TX_PREPRIO_1          (2) // for DMA
#define     __uTRACER_TX_SUBPRIO_1          (3) // for DMA

#if (__TRACER_FLWCNTL == _TRACER_ON) // note : used for upper API
// en? am I available? :: 0 free; 1 : busy
#define     __uTRACER_CTS_PORT_N_1          (io_Port_0)
#define     __uTRACER_CTS_PIN_N_1           (io_Pin_11)
#define     __uTRACER_CTS_MODE_1            (io_Mode_OOD)
// hi baby, I am coming
#define     __uTRACER_RTS_PORT_N_1          (io_Port_0)
#define     __uTRACER_RTS_PIN_N_1           (io_Pin_12)
#define     __uTRACER_RTS_MODE_1            (io_Mode_FIN)
#endif // (__TRACER_FLWCNTL == _TRACER_ON)

#if   (__MCU_TYPE == _MCU_IS_STM32L1x)
#define     __TRACER_IO_SPEED_N_1           (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32F10x)
#define     __uTRACER_IO_SPEED_N_1          (is_50MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __uTRACER_IO_SPEED_N_1          (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#define     __uTRACER_IO_SPEED_N_1          (is_10MHz)    // for efm32TGxx, meaningless
#elif (__MCU_TYPE == _MCU_IS_NRF51822)
#define     __uTRACER_IO_SPEED_N_1          (is_10MHz)    // for efm32TGxx, meaningless
#elif (__MCU_TYPE == _MCU_IS_NRF52832)
#define     __uTRACER_IO_SPEED_N_1          (is_10MHz)    // for efm32TGxx, meaningless
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define     __uTRACER_IO_SPEED_N_1          (is_10MHz)    // for efm32TGxx, meaningless
#endif

#define     __uTRACER_TX_PORT_N_1           (io_Port_0)     // TXD || MOSI
#define     __uTRACER_TX_PIN_N_1            (io_Pin_09)     // TXD || MOSI
#if   ((__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32Gxxx))
#define     __uTRACER_TX_MODE_1             (io_Mode_OOP)        // TXD || MOSI
#elif (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#define     __uTRACER_TX_MODE_1             (io_Mode_OOP)        // TXD || MOSI
#else
#define     __uTRACER_TX_MODE_1             (io_Mode_APP)        // TXD || MOSI
#endif

#define     __uTRACER_RX_PORT_N_1           (io_Port_0)     // RXD || MISO
#define     __uTRACER_RX_PIN_N_1            (io_Pin_10)     // RXD || MISO
#define     __uTRACER_RX_MODE_1             (io_Mode_FIN)        // RXD || MISO

#define     __uTRACER_SCK_PORT_N_1          (io_Port_No)     // for spi use
#define     __uTRACER_SCK_PIN_N_1           (io_Pin_No)     // for spi use
#define     __uTRACER_SCK_MODE_1            (io_Mode_No)        // for spi use
// hi baby, I am coming
#define     __uTRACER_RTS_PORT_N_1          (io_Port_No)     // MCU RTS
#define     __uTRACER_RTS_PIN_N_1           (io_Pin_No)     // MCU RTS
#define     __uTRACER_RTS_MODE_1            (io_Mode_No)        // MCU RTS
// en? am I available? :: 0 free; 1 : busy
#define     __uTRACER_CTS_PORT_N_1          (io_Port_No)     // MCU CTS
#define     __uTRACER_CTS_PIN_N_1           (io_Pin_No)     // MCU CTS
#define     __uTRACER_CTS_MODE_1            (io_Mode_No)        // MCU CTS

#define     __uTRACER_DTR_PORT_N_1          (io_Port_No)     // MCU DTR
#define     __uTRACER_DTR_PIN_N_1           (io_Pin_No)     // MCU DTR
#define     __uTRACER_DTR_MODE_1            (io_Mode_No)        // MCU DTR

#define     __uTRACER_DSR_PORT_N_1          (io_Port_No)     // MCU DTR
#define     __uTRACER_DSR_PIN_N_1           (io_Pin_No)     // MCU DTR
#define     __uTRACER_DSR_MODE_1            (io_Mode_No)        // MCU DTR

#define     __uTRACER_DCD_PORT_N_1          (io_Port_No)     // MCU DCD
#define     __uTRACER_DCD_PIN_N_1           (io_Pin_No)     // MCU DCD
#define     __uTRACER_DCD_MODE_1            (io_Mode_No)        // MCU DCD

#define     __uTRACER_RI_PORT_N_1           (io_Port_No)     // MCU RI
#define     __uTRACER_RI_PIN_N_1            (io_Pin_No)     // MCU RI
#define     __uTRACER_RI_MODE_1             (io_Mode_No)        // MCU RI

#define     __uTRACER_CS_PORT_N_1           (io_Port_No)     // for spi use
#define     __uTRACER_CS_PIN_N_1            (io_Pin_No)     // for spi use
#define     __uTRACER_CS_MODE_1             (io_Mode_No)        // for spi use

#endif // (__uTRACER_CNT >= 1)

#if (__uTRACER_CNT >= 2)
#error "not supportted!"
#endif // (__uTRACER_CNT >= 2)

#if (__sTRACER_CNT >= 1)
#define     __sTracer_Index_1               (0x00)


#define     __sTRACER_BUS_1                 (_HSPI3) // choose the channel
#define     __sTRACER_ROLE_1                (_MASTER_SPI) // must be slave
#define     __sTRACER_BDR_1                 (_SPI_BR_Prescaler_16)
#define     __sTRACER_CPOL_1                (_SPI_CPOL_Low)
#define     __sTRACER_CPHA_1                (_SPI_CPHA_1Edge)

#define     __sTRACER_ISR_MODE_1            /* (_TRACER_ISR_DMA) // */ (_TRACER_ISR_NODMA)

#if (__sTRACER_ISR_MODE_1 ==_TRACER_ISR_DMA)
#define     __sTRACER_TIMER_BUS_1           (is_tim06)
#define     __sTRACER_TIMER                 (TIM6) // for optimization, make sure it matches with __sTRACER_TIMER_BUS_1
#define     __sTRACER_TIMER_PREPRIO_1       (2)
#define     __sTRACER_TIMER_SUBPRIO_1       (2)
#endif

#if   (__sTRACER_ISR_MODE_1 == _TRACER_ISR_NODMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __sTRACER_RCVISR_FLAG_1         (USART_IF_RXDATAV)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F10x) || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx) || \
       (__MCU_TYPE == _MCU_IS_STM32L0x))
#define     __sTRACER_RCVISR_FLAG_1         (SPI_I2S_IT_RXNE)
#else
#endif

#elif   (__sTRACER_ISR_MODE_1 == _TRACER_ISR_DMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __sTRACER_RCVISR_FLAG_1         (USART_IT_IDLE)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F10x) || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx))
#define     __sTRACER_RCVISR_FLAG_1         (SPI_I2S_IT_RXNE)
#elif  (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __sTRACER_RCVISR_FLAG_1         (SPI_IT_RXNE)
#else
#endif // __MCU_TYPE

#endif // (__sTRACER_ISR_MODE_1 == _TRACER_ISR_NODMA)

#if   (__sTRACER_ISR_MODE_1 == _TRACER_ISR_NODMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __sTRACER_TXISR_FLAG_1          (USART_IF_TXC)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F10x) || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx))
#define     __sTRACER_TXISR_FLAG_1          (SPI_I2S_IT_TXE)
#elif  (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __sTRACER_TXISR_FLAG_1          (SPI_IT_TXE)
#else
#endif // __MCU_TYPE

#elif   (__sTRACER_ISR_MODE_1 == _TRACER_ISR_DMA)

#if   ((__MCU_TYPE == _MCU_IS_EFM32Gxxx)  || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32ZGxxx))
#define     __sTRACER_TXISR_FLAG_1          (USART_IF_TXC)
#elif ((__MCU_TYPE == _MCU_IS_STM32L1x)  || \
       (__MCU_TYPE == _MCU_IS_STM32F10x) || \
       (__MCU_TYPE == _MCU_IS_STN32F0xx))
#define     __sTRACER_TXISR_FLAG_1          (SPI_I2S_IT_TXE)
#elif  (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __sTRACER_TXISR_FLAG_1          (SPI_IT_TXE)
#else
#endif // __MCU_TYPE

#else

#endif // (__sTRACER_ISR_MODE_1 == _TRACER_ISR_NODMA)

#define     __sTRACER_RX_PREPRIO_1          (2)
#define     __sTRACER_RX_SUBPRIO_1          (3)
#define     __sTRACER_TX_PREPRIO_1          (2) // for DMA
#define     __sTRACER_TX_SUBPRIO_1          (3) // for DMA

extern void rvHciDataPresentCallBack(void);
#define     __RFCHIP_DAT_IRQ_ROUTINE        (rvHciDataPresentCallBack) // */ NULL
#define     __RFCHIP_DAT_IRQ_PIN            /* (_RFCHIP_GDO3) // */ (_RFCHIP_GDO2)
#define     __RFCHIP_DAT_IRQ_PrePrio        (2u)
#define     __RFCHIP_DAT_IRQ_SubPrio        (0u)

#if (__TRACER_FLWCNTL == _TRACER_ON) // note : used for upper API
// en? am I available? :: 0 free; 1 : busy
#define     __sTRACER_CTS_PORT_N_1          (io_Port_0)
#define     __sTRACER_CTS_PIN_N_1           (io_Pin_11)
#define     __sTRACER_CTS_MODE_1            (io_Mode_OOD)
// hi baby, I am coming
#define     __sTRACER_RTS_PORT_N_1          (io_Port_0)
#define     __sTRACER_RTS_PIN_N_1           (io_Pin_12)
#define     __sTRACER_RTS_MODE_1            (io_Mode_FIN)
#endif // (__TRACER_FLWCNTL == _TRACER_ON)

#if   (__MCU_TYPE == _MCU_IS_STM32L1x)
#define     __sTRACER_IO_SPEED_N_1           (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32F10x)
#define     __sTRACER_IO_SPEED              (is_50MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __sTRACER_IO_SPEED              (is_10MHz)    // for stm32l1x; (is_50MHz) // for stm32f10x
#elif (__MCU_TYPE == _MCU_IS_EFM32TGxxx)
#define     __sTRACER_IO_SPEED              (is_10MHz)    // for efm32TGxx, meaningless
#endif

#define     __sTRACER_TX_PORT_N_1           (io_Port_1)     // TXD || MOSI
#define     __sTRACER_TX_PIN_N_1            (io_Pin_05)     // TXD || MOSI

#define     __sTRACER_RX_PORT_N_1           (io_Port_1)     // RXD || MISO
#define     __sTRACER_RX_PIN_N_1            (io_Pin_04)     // RXD || MISO

#define     __sTRACER_SCK_PORT_N_1          (io_Port_1)     // for spi use
#define     __sTRACER_SCK_PIN_N_1           (io_Pin_03)     // for spi use

#define     __sTRACER_CS_PORT_N_1           (io_Port_2)     // for spi use
#define     __sTRACER_CS_PIN_N_1            (io_Pin_14)     // for spi use

#define     __sTRACER_SYNC_PORT_N_1         (io_Port_1)     // for spi use
#define     __sTRACER_SYNC_PIN_N_1          (io_Pin_15)     // for spi use

#endif // (__sTRACER_CNT >= 1)

#if (__sTRACER_CNT >= 2)
#error "not supported!"
#endif

#endif // (defined __TRACER_MODULE) && (__TRACER_MODULE == _MODULE_ON)

/**** LCD_sFLASH Module *******************************************************/
#if (defined __LCD_sFLASH_MODULE) && (__LCD_sFLASH_MODULE == _MODULE_ON)

/***** Peripheral Type ********************************************************/
#define __USED_LCD_TYPE                 (__LCD_UPD161704)
#define __USED_sFLASH_TYPE              (__sFLASH_W25Q16)

/**** LCD Info ****************************************************************/
#define __LCD_PIXEL_SIZE                (16ul)
#define __LCD_X_SIZE                    (240u)
#define __LCD_Y_SIZE                    (320u)

/**** LCD_DEBUG Status ********************************************************/
#define __LCD_DBG_Status                (_LCD_DEBUG)

/***** GPIO Configuration *****************************************************/
#define __LCD_GPIO_SPEED                (GPIO_Speed_50MHz)

#define __LCD_LED_PORT_BASE             (GPIOC_BASE)  //  LED
#define __LCD_LED_PIN_NUM               (14U)
#define __LCD_RST_PORT_BASE             (GPIOC_BASE)  // RST, connect to MCU RST Pin directly
#define __LCD_RST_PIN_NUM               (0U)
#define __LCD_CS_PORT_BASE              (GPIOC_BASE)  // CS
#define __LCD_CS_PIN_NUM                (4U)
#define __LCD_RD_PORT_BASE              (GPIOA_BASE)  // RD
#define __LCD_RD_PIN_NUM                (4U)
/**** LCD WR pin must locate on the same port as SSPI CLK pins ****************/
#define __LCD_WR_PORT_BASE              (GPIOA_BASE)  // wr, check if the port is the same with sFlash sck
#define __LCD_WR_PIN_NUM                (3U)          // the pin should be different
#define __LCD_RS_PORT_BASE              (GPIOC_BASE)  // RS
#define __LCD_RS_PIN_NUM                (5U)
#define __LCD_sFLASH_DATA_PORT_BASE     (GPIOB_BASE)  // DATA_Pins
#define __LCD_sFLASH_DATA_PIN           (0x00FF)

/**** Module Switch ***********************************************************/
#define __BMP_MODULE                    (_LCD_DISABLE)
#define __ICON_MODULE                   (_LCD_DISABLE)
#define __GRAPH_2D_MODULE               (_LCD_ENABLE)
#define __TEXT_MODULE                   (_LCD_DISABLE)
#if (defined __TEXT_MODULE) && (__TEXT_MODULE != _LCD_DISABLE)
#define __NUM_DISP_MODULE               (_LCD_ENABLE)
#else
#define __NUM_DISP_MODULE               (_LCD_DISABLE)
#endif // (TEXT_MODULE > _GUI_DISABLED)

/**** Fonts Storing configuration *********************************************/
/**** FONT Configuration ******************************************************/
/**** Fonts Switch ************************************************************/
#if (defined __TEXT_MODULE) && (__TEXT_MODULE == _LCD_ENABLE)
#define __Font_dzlt_14_14_SWITCH        (_LCD_ENABLE)
#define __Font_dzlt_10_SWITCH           (_LCD_ENABLE)
#define __UNICODE_SUPPORT               (_LCD_ENABLE)
#else
#define __Font_dzlt_14_14_SWITCH        (_LCD_DISABLE)
#define __Font_dzlt_10_SWITCH           (_LCD_DISABLE)
#define __UNICODE_SUPPORT               (_LCD_DISABLE)
#endif // TEXT_MODULE > _GUI_DISABLED

#define __FONT_CNT_IN_FLASH             (0x03u)         // for LCD, 3 Fonts is enough!
/**** please remember, font1 must be a full and the longest charset lib *******/
#define __FONT1_COUNT                   (8000ul)        // the maximum number allocated for storing font1
#define __FONT1_SIZE                    (14ul)          // FONT <= 14*14 Full
#define __FONT2_COUNT                   (__FONT1_COUNT) // the maximum number allocated for storing font2
#define __FONT2_SIZE                    (24ul)          // FONT <= 24*24 Full
#define __FONT3_COUNT                   (200ul)         // the maximum number allocated for storing font3
#define __FONT3_SIZE                    (36ul)          // FONT <= 36*36 Partial

#if (defined __TEXT_MODULE) && (__TEXT_MODULE == _LCD_ENABLE)
#define __FONT1                         GUI_FontHZdzlt10_CharInfo
#define __FONT2                         GUI_FontHZdzlt_14_14_No_10_CharInfo
#define __FONT3                         GUI_FontHZdzlt10_CharInfo

#define __FONT_SIZE_16                  (1u)
#define __FONT_SIZE_24                  (1u)
#define __FONT_SIZE_32                  (1u)
#else
#define __FONT1                         (1u)
#define __FONT2                         (2u)
#define __FONT3                         (3u)

#define __FONT_SIZE_16                  (__FONT1)
#define __FONT_SIZE_24                  (__FONT2)
#define __FONT_SIZE_32                  (__FONT3)
#endif

/**** BMPs Storing configuration **********************************************/
#define __STORED_BMP_COUNT              (17U)

/**** BMPs Switch *************************************************************/
#if (defined __BMP_MODULE) && (__BMP_MODULE ==  _LCD_ENABLE)
#define __bm_taskbar_SWITCH             (_LCD_ENABLE)
#define __bm_remote_SWITCH              (_LCD_ENABLE)
#define __bm_button_SWITCH              (_LCD_ENABLE)
#define __bm_button_white_SWITCH        (_LCD_ENABLE)
#define __bm_FancoilCold_SWITCH         (_LCD_ENABLE)
#define __bm_FancoilHot_SWITCH          (_LCD_ENABLE)
#else
#define __bm_taskbar_SWITCH             (_LCD_DISABLE)
#define __bm_remote_SWITCH              (_LCD_DISABLE)
#define __bm_button_SWITCH              (_LCD_DISABLE)
#define __bm_button_white_SWITCH        (_LCD_DISABLE)
#define __bm_FancoilCold_SWITCH         (_LCD_DISABLE)
#define __bm_FancoilHot_SWITCH          (_LCD_DISABLE)
#endif // (__BMP_MODULE > _GUI_DISABLED)

/**** ICONs Switch ************************************************************/
#if (defined __ICON_MODULE) && (__ICON_MODULE != _LCD_DISABLE)
 #define __ico_AirCon_SWITCH            (_LCD_ENABLE)
 #define __ico_CD_SWITCH                (_LCD_ENABLE)
 #define __ico_COPY_SWITCH              (_LCD_ENABLE)
 #define __ico_DVD_SWITCH               (_LCD_ENABLE)
 #define __ico_DVD_56_SWITCH            (_LCD_ENABLE)
 #define __ico_Arrow_SWITCH             (_LCD_ENABLE)
 #define __ico_Frame_SWITCH             (_LCD_ENABLE)
 #define __ico_NT_Config_SWITCH         (_LCD_ENABLE)
 #define __ico_SCENE_SWITCH             (_LCD_ENABLE)
 #define __ico_SETTOP_SWITCH            (_LCD_ENABLE)
 #define __ico_SWITCH_SWITCH            (_LCD_ENABLE)
 #define __ico_TV_SWITCH                (_LCD_ENABLE)
#else
#define __ico_AirCon_SWITCH             (_LCD_DISABLE)
#define __ico_CD_SWITCH                 (_LCD_DISABLE)
#define __ico_COPY_SWITCH               (_LCD_DISABLE)
#define __ico_DVD_SWITCH                (_LCD_DISABLE)
#define __ico_DVD_56_SWITCH             (_LCD_DISABLE)
#define __ico_Arrow_SWITCH              (_LCD_DISABLE)
#define __ico_Frame_SWITCH              (_LCD_DISABLE)
#define __ico_NT_Config_SWITCH          (_LCD_DISABLE)
#define __ico_SCENE_SWITCH              (_LCD_DISABLE)
#define __ico_SETTOP_SWITCH             (_LCD_DISABLE)
#define __ico_SWITCH_SWITCH             (_LCD_DISABLE)
#define __ico_TV_SWITCH                 (_LCD_DISABLE)
#endif // (ICON_MODULE > _GUI_DISABLED)

/**** __BMP1: 240 * 320 bm_wmplayer *******************************************/
#if (defined __STORED_BMP_COUNT) && (__STORED_BMP_COUNT >= 1)
 extern const LCD_sFlash_BMP_TypeDef    bmp_FancoilCold;
 #define __BMP1                         (&bmp_FancoilCold)
 #define __BMP1_WIDTH                   (240ul)
 #define __BMP1_LENGTH                  (320ul)
 #define __BMP1_TYPE                    (_BMP_TYPE)
#endif // (defined __STORED_BMP_COUNT) && (__STORED_BMP_COUNT >= 1)

/**** __BMP2: 100 * 231 bm_remote *********************************************/
 extern const LCD_sFlash_BMP_TypeDef    bmp_FancoilHot;
 #define __BMP2                         (&bmp_FancoilHot)
 #define __BMP2_WIDTH                   (240ul)
 #define __BMP2_LENGTH                  (320ul)
 #define __BMP2_TYPE                    (_BMP_TYPE)

/**** __BMP3: 240 * 25 bm_taskbar *********************************************/
 extern const LCD_sFlash_BMP_TypeDef    bmp_remote;
 #define __BMP3                         (&bmp_remote)
 #define __BMP3_WIDTH                   (100ul)
 #define __BMP3_LENGTH                  (231ul)
 #define __BMP3_TYPE                    (_BMP_TYPE)

/**** __BMP4: 240 * 30 bm_button **********************************************/
 extern const LCD_sFlash_BMP_TypeDef    bmp_button;
 #define __BMP4                         (&bmp_button)
 #define __BMP4_WIDTH                   (240ul)
 #define __BMP4_LENGTH                  (30ul)
 #define __BMP4_TYPE                    (_BMP_TYPE)

/**** __BMP5: 70 * 30 bm_button_white_70_30 ***********************************/
 extern const LCD_sFlash_BMP_TypeDef    bmp_button_white;
 #define __BMP5                         (&bmp_button_white)
 #define __BMP5_WIDTH                   (70ul)
 #define __BMP5_LENGTH                  (30ul)
 #define __BMP5_TYPE                    (_BMP_TYPE)

/**** __BMP6: 36 * 36 bm_AirCon ***********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_AirCon;
 #define __BMP6                         (&ico_AirCon)
 #define __BMP6_WIDTH                   (36ul)
 #define __BMP6_LENGTH                  (36ul)
 #define __BMP6_TYPE                    (_ICO_TYPE)

/**** __BMP7: 36 * 36 bm_CD ***************************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_CD;
 #define __BMP7                         (&ico_CD)
 #define __BMP7_WIDTH                   (36ul)
 #define __BMP7_LENGTH                  (36ul)
 #define __BMP7_TYPE                    (_ICO_TYPE)

/**** __BMP8: 36 * 36 bm_COPY *************************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_COPY;
 #define __BMP8                         (&ico_COPY)
 #define __BMP8_WIDTH                   (36ul)
 #define __BMP8_LENGTH                  (36ul)
 #define __BMP8_TYPE                    (_ICO_TYPE)

/**** __BMP9: 36 * 36 bm_DVD **************************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_DVD;
 #define __BMP9                         (&ico_DVD)
 #define __BMP9_WIDTH                   (36ul)
 #define __BMP9_LENGTH                  (36ul)
 #define __BMP9_TYPE                    (_ICO_TYPE)

/**** __BMP10: 36 * 36 bm_DVD_56 **********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_DVD_56;
 #define __BMP10                        (&ico_DVD_56)
 #define __BMP10_WIDTH                  (56ul)
 #define __BMP10_LENGTH                 (56ul)
 #define __BMP10_TYPE                   (_ICO_TYPE)

/**** __BMP11: 23 * 22 bm_Arrow ***********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_Arrow;
 #define __BMP11                        (&ico_Arrow)
 #define __BMP11_WIDTH                  (23ul)
 #define __BMP11_LENGTH                 (22ul)
 #define __BMP11_TYPE                   (_ICO_TYPE)

/**** __BMP12: 56 * 56 bm_Frame ***********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_Frame;
 #define __BMP12                        (&ico_Frame)
 #define __BMP12_WIDTH                  (56ul)
 #define __BMP12_LENGTH                 (56ul)
 #define __BMP12_TYPE                   (_ICO_TYPE)

/**** __BMP13: 36 * 36 bm_NT_Config *******************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_NT_Config;
 #define __BMP13                        (&ico_NT_Config)
 #define __BMP13_WIDTH                  (36ul)
 #define __BMP13_LENGTH                 (36ul)
 #define __BMP13_TYPE                   (_ICO_TYPE)

/**** __BMP14: 36 * 36 bm_SCENE ***********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_SCENE;
 #define __BMP14                        (&ico_SCENE)
 #define __BMP14_WIDTH                  (36ul)
 #define __BMP14_LENGTH                 (36ul)
 #define __BMP14_TYPE                   (_ICO_TYPE)

/**** __BMP15: 36 * 36 bm_SETTOP **********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_SETTOP;
 #define __BMP15                        (&ico_SETTOP)
 #define __BMP15_WIDTH                  (36ul)
 #define __BMP15_LENGTH                 (36ul)
 #define __BMP15_TYPE                   (_ICO_TYPE)

/**** __BMP16: 36 * 36 bm_SWITCH ***********************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_SWITCH;
 #define __BMP16                        (&ico_SWITCH)
 #define __BMP16_WIDTH                  (36ul)
 #define __BMP16_LENGTH                 (36ul)
 #define __BMP16_TYPE                   (_ICO_TYPE)

/**** __BMP17: 36 * 36 bm_TV ***************************************************/
 extern const LCD_sFlash_BMP_TypeDef    ico_TV;
 #define __BMP17                        (&ico_TV)
 #define __BMP17_WIDTH                  (36ul)
 #define __BMP17_LENGTH                 (36ul)
 #define __BMP17_TYPE                   (_ICO_TYPE)

#endif // (defined __LCD_sFLASH_MODULE) && (__LCD_sFLASH_MODULE == _MODULE_ON)

/**** RULEOS Module ***********************************************************/
/**** Defines *****************************************************************/
#if (defined __RULEOS_MODULE) && (_MODULE_ON == __RULEOS_MODULE)
#include <ruleSpec.h>

#define     __RULE_ETH_NEW_MAGIC              (0x79u)
#define     __RULE_ETH_NEW_VER                (0x01u)

#ifdef __DAHAO
#define     __RULE_EDITION                    (_RULE_EDITION_DAHAO)
#else
#define     __RULE_EDITION                    (_RULE_EDITION_HOME)
#endif

#define     __RULE_DBG_TRACER_SEND(fm, ...)

#define     __RULE_USE_LIST_BUFFER
#define     __RULE_USE_HCI_INTERFACE
#ifdef      __RULE_USE_HCI_INTERFACE
#define     __RULE_HCI_CONSOLE_INDEXx         (__sTracer_Index_1)
#endif

#define     __RULE_NVM_DATA_BASE              (0x12345678ull)

 // 0B 04 05 0F 02 11 : 客厅灯
 // 0B 04 05 0F 02 12 ：卧室灯
 // 0B 04 05 0F 02 01 ：卧室门
 // 0B 04 05 0F 02 02 ：客厅窗
#define     __RULE_PID_LST_BYTE               (0x02u)
#define     __RULE_UID_LST_BYTE               (__RULE_PID_LST_BYTE)
#define     __RULE_DEV_TOKEN                  (0x12345678ul)

extern void dahaoSyncAfterRoutine (void);
#define     __RULE_SYNC_CALLBACK_AFTER        dahaoSyncAfterRoutine // */ NULL

// FOR TEST, YOU CAN ADD A x TO SHUT IT OFF
#define     __RULE_ISR_DEBUG
#define     __RULECONNLISTEN_DBG              (0)
#define     __RULE_STARTUP_DELAY              (0x06ul)
#define     __RULE_RND_START                  (5)
#define     __RULE_PROTOCOL_HOP               (0x00)

#ifdef __DAHAO
#define     _RULE_ENNET_STRATEGYx             (_RULE_ENNET_SAVE_POWER)
#else
#define     _RULE_ENNET_STRATEGY              (_RULE_ENNET_SAVE_POWER)
#endif

#define     __RULE_EXT_NBR                    (0) // only for AP

#define     __RULE_ETH_VER                    (0x0100u)
#define     __RULE_ETH_MAGIC                  (0x00345678u) // ff for endian needed to be filled!

#define     __RULE_INTERFACE                  (_RULE_IMPLEMENTATION)

#if (__RULE_INTERFACE == _RULE_IMPLEMENTATION)

#define     __RULE_DEV_PRIADDR                (_RULE_AP_ADDR) // dynamic IP
#define     __RULE_NWK_ROLE                   (_RULE_COR_DEV)

// 0x01 : 15625 ms, 0x02 : 125 ms, 0x03 : 250 ms, 0x04 : 500 ms, 0x05 : 1000 ms, 0x06 : 2000ms
#ifdef __DAHAO
#define     __RULE_NWK_WAKEUP                 (0x00)
#else
#define     __RULE_NWK_WAKEUP                 (0x00)
#endif

#define     __RULE_CCASEND_MODE               (_RADIO_CCA_OFF_SEND) // */ (_RADIO_CCA_OFF_SEND)
#define     __RULE_ENCRYPTION                 (_RULE_xENCRYPTED)
#define     __RULE_BUF_TX_SIZE                (0x06ul)

#if (__RULE_NWK_ROLE == _RULE_END_DEV)
#define     __KS_SYNC_DAD_ADDR                (_RULE_AP_ADDR) // x for dynamic routing
#endif

#define     __KS_DEV_MAX_SUBADDR              /* (0x02) // */ (0x00) // 0, 1, 2

#if   ((__MCU_TYPE == _MCU_IS_EFM32ZGxxx) || \
       (__MCU_TYPE == _MCU_IS_EFM32TGxxx))
#define     __RULE_TIMER_BUS                  (__KS_TIMER_RTC) // */ (is_tim00)
#elif  (__MCU_TYPE == _MCU_IS_STM32L0x)
#define     __RULE_TIMER_BUS                  (__KS_TIMER_LPW)
#elif  (__MCU_TYPE == _MCU_IS_EFR32BG1Pxxx)
#if (__RULE_NWK_WAKEUP == 0x00)
#define     __RULE_TIMER_BUS                  (__KS_TIMER_000)
#ifdef __DAHAO
// 32  : 4/5[40.0] us/tick : 19531.25 -> 15625; 39062.5 -> 31250 (512 * 0.8 = 409.6)
// 32  : 5/6[38.4] us/tick : 18750    -> 15625; 37500   -> 31250 (512 * 5/6 = 426.667)
#define     __RULE_TIMER_NUMERATOR_AIR    (0x01)
#define     __RULE_TIMER_DENOMINATOR_AIR  (0x0A)
#define     __RULE_COMPENSATION_CNTR      (-8) // plus 1 us / 8 ticks
#define     __RULE_COMPENSATION_TICK      (10) // 10 tick for 1 us here

#else // __DAHAO
// 32  : 4/5[40.0] us/tick : 19531.25 -> 15625; 39062.5 -> 31250 (512 * 0.8 = 409.6)
// 32  : 5/6[38.4] us/tick : 18750    -> 15625; 37500   -> 31250 (512 * 5/6 = 426.667)
#define     __RULE_TIMER_NUMERATOR_AIR    (0x04)
#define     __RULE_TIMER_DENOMINATOR_AIR  (0x05)
#define     __RULE_TIMER_COMPENSATION     (-4) // plus 0.8 us/4 ticks
#endif // __DAHAO

#else // __RULE_NWK_WAKEUP
#define     __RULE_TIMER_BUS                  (__KS_TIMER_RTC)
// the timer is faster : 19531 -> 15624.8 12.8us/sec 200us/16sec
#endif // __RULE_NWK_WAKEUP

#elif  (__MCU_TYPE == _MCU_IS_NRF51822)
#if (__RULE_NWK_WAKEUP == 0x00)

#define     __RULE_TIMER_BUS                  (__KS_TIMER_000)
#define     __RULE_TIMER_NUMERATOR_AIR        (0x01)
#define     __RULE_TIMER_DENOMINATOR_AIR      (0x08)
#else // __RULE_NWK_WAKEUP
#define     __RULE_TIMER_BUS                  (__KS_TIMER_RTC)
#endif
#elif  (__MCU_TYPE == _MCU_IS_NRF52832)
#if (__RULE_NWK_WAKEUP == 0x00)
#define     __RULE_TIMER_BUS                  (__KS_TIMER_001)
// 32  : 1/8[16.0] us/tick : 15625    -> 15625; 31250   -> 31250 (512 * 5/6 = 426.667)
#else // __RULE_NWK_WAKEUP
#define     __RULE_TIMER_BUS                  (__KS_TIMER_RTC1)
#endif // __RULE_NWK_WAKEUP
#else // __MCU_TYPE
#define     __RULE_TIMER_BUS                  (__KS_TIMER_000)
#endif // __MCU_TYPE

#define     __RULE_TIMER_UNITS_POW2           /* (_RULE_NUM_31250) // */ (_RULE_NUM_15625) // important, the us/tick

#define     __RULE_TIMER_PRIPRIO              (0)   // DELAY in sync isr, lower than that
#define     __RULE_TIMER_SUBPRIO              (0)

#define     __RULE_TXRX_IRQ_ROUTINE           (__RADIO_TRx_IRQ_ROUTINE) // */ NULL

#if     (__RULE_NWK_ROLE == _RULE_END_DEV)
#define     __RULE_DEV_CMD_TYPE               (_RULE_DEV_TERMINAL)
#define     __RULE_CONSOLE_N                  (__TRACER_CONSOLE)
#elif   (__RULE_NWK_ROLE == _RULE_COR_DEV)
#define     __RULE_DEV_CMD_TYPE               (_RULE_DEV_TERMINAL)
#define     __RULE_CONSOLE_N                  (__TRACER_CONSOLE)
#elif   (__RULE_NWK_ROLE == _RULE_EXT_DEV)

#endif

#endif // (__RULE_INTERFACE == _RULE_IMPLEMENTATION)

#endif // __RULEOS_MODULE

/**** KeyPads Module **********************************************************/
#if (defined __KEYPADS_MODULE) && (_MODULE_ON == __KEYPADS_MODULE)
#include <KeyPads_Spec.h>

/***** Choose Key Pad type: __KEY_ARRAY || __KEY_BUTTON ***********************/
#define    __KEYPADS_INTERFACE            (__KEY_BUTTON)
#define    __KEYPADS_IO_SPEED             (is_02MHz)
#define    __KEYPADS_ANTISHAKE_TIMER      (is_tim04)
#define    __KEYPADS_ANTISHAKE_PERIOD     (50) // ms
#define    __ANTISHAKE_TIMER_NVIC_PRE     (3)
#define    __ANTISHAKE_TIMER_NVIC_SUB     (0)

 #if (__KEY_ARRAY == __KEYPADS_INTERFACE)
 #define     __KEY_ARRAY_NUM             (3u)            // only define pins to form the array

 #define     __KEYPADS_IRQ_PORT_BASE     (GPIOA_BASE)    // Key_Irq_Pin
 #define     __KEYPADS_IRQ_PIN_NUM       (0U)
 #define     __KEYPADS_ARRAY_IRQ_MODE    (__FALLING_EDGE_TRIGGER)
 #define     __KEYPADS_IRQ_INITSTATUS    (__INIT_HIGH)
 #define     __KEYARRAY_NVIC_PRE         (0)
 #define     __KEYARRAY_NVIC_SUB         (0)

 #define     __KEYPADS_PULL_PORT_BASE    (GPIOA_BASE)    // Key_Pull_Pin
 #define     __KEYPADS_PULL_PIN_NUM      (15U)
 #define     __KEYPADS_PULL_IRQ_MODE     (__NONE_TRIGGER)
 #define     __KEYPADS_PULLL_INITSTATUS  (__INIT_HIGH)
#elif   (__KEY_BUTTON == __KEYPADS_INTERFACE)
#define     __KEY_BUTTON_NUM              (1)
 #else
 #error  Wrong KeyPads Interface!!
 #endif

 /***** Key Pads GPIO Configuration ************************************************/
#if (__KEY_BUTTON_NUM > 0) || (__KEY_ARRAY_NUM > 0)

extern void ApKeyReleasedCallBack(unsigned char keyNb);
extern void ApKeyPressedCallBack(unsigned char keyNb);

#define     __KEYPADS_KEY_RESET           (0) // for callback, give it a name

// STUDY KEY :: PC8 // STUDY
#define     __KEYPADS_KEY1_PORT           (io_Port_4)
#define     __KEYPADS_KEY1_PIN_N          (io_Pin_15)
#define     __KEYPADS_KEY1_MODE           (io_Mode_FIN)
#define     __KEYPADS_KEY1_IRQ_MODE       (Falling)
#define     __KEYPADS_KEY1_INITSTATUS     (__INIT_HIGH)
#define     __KEYPADS_KEY1_NVIC_PRE       (3)
#define     __KEYPADS_KEY1_NVIC_SUB       (1)
#define     __KEYPADS_KEY1_DPRESS_MS      (120)   // ms
#define     __KEYPADS_KEY1_LPRESS_MS      (3000)  // ms
#define     __KEYPADS_KEY1_DPRESS_1ST     (1)    // 1 for true, 0 for false
#define     __KEYPADS_KEY1_PRESSED_CB     (ApKeyPressedCallBack)
#define     __KEYPADS_KEY1_ANTISHAKE_CB   (ApKeyPressedCallBack)
#define     __KEYPADS_KEY1_SPRESSED_CB    (ApKeyReleasedCallBack)
#define     __KEYPADS_KEY1_DPRESSED_CB    (ApKeyReleasedCallBack)
#define     __KEYPADS_KEY1_LPRESSED_CB    (ApKeyReleasedCallBack)
#endif // (__KEY_BUTTON_NUM > 0) || (__KEY_ARRAY_NUM > 0)

#if (__KEY_BUTTON_NUM > 1) || (__KEY_ARRAY_NUM > 1)
extern void Reset_Key_CallBack(unsigned char keyNb);

// RESET KEY :: PE4 // RST
#define     __KEYPADS_KEY2_PORT           (io_Port_4)
#define     __KEYPADS_KEY2_PIN_N          (io_Pin_04)
#define     __KEYPADS_KEY2_MODE           (io_Mode_IPU)
#define     __KEYPADS_KEY2_IRQ_MODE       (Falling)
#define     __KEYPADS_KEY2_INITSTATUS     (__INIT_HIGH)
#define     __KEYPADS_KEY2_NVIC_PRE       (3)
#define     __KEYPADS_KEY2_NVIC_SUB       (1)
#define     __KEYPADS_KEY2_CALLBACK       (Reset_Key_CallBack)

#endif // (__KEY_BUTTON_NUM > 1) || (__KEY_ARRAY_NUM > 1)

#if (__KEY_BUTTON_NUM > 2) || (__KEY_ARRAY_NUM > 2)
#define     __KEYPADS_KEY3_PORT_BASE    (GPIOA_BASE)
#define     __KEYPADS_KEY3_PIN_NUM      (12U)
#define     __KEYPADS_KEY3_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY3_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY3_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY3_NVIC_PRE     (3)
#define     __KEYPADS_KEY3_NVIC_SUB     (1)
#endif // (__KEY_BUTTON_NUM > 2) || (__KEY_ARRAY_NUM > 2)

#if (__KEY_BUTTON_NUM > 3) || (__KEY_ARRAY_NUM > 3)
#define     __KEYPADS_KEY4_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY4_PIN_NUM      (11U)
#define     __KEYPADS_KEY4_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY4_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY4_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY4_NVIC_PRE     (0)
#define     __KEYPADS_KEY4_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 3) || (__KEY_ARRAY_NUM > 3)

#if (__KEY_BUTTON_NUM > 4) || (__KEY_ARRAY_NUM > 4)
#define     __KEYPADS_KEY5_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY5_PIN_NUM      (11U)
#define     __KEYPADS_KEY5_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY5_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY5_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY5_NVIC_PRE     (0)
#define     __KEYPADS_KEY5_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 4) || (__KEY_ARRAY_NUM > 4)

#if (__KEY_BUTTON_NUM > 5) || (__KEY_ARRAY_NUM > 5)
#define     __KEYPADS_KEY6_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY6_PIN_NUM      (11U)
#define     __KEYPADS_KEY6_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY6_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY6_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY6_NVIC_PRE     (0)
#define     __KEYPADS_KEY6_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 5) || (__KEY_ARRAY_NUM > 5)

#if (__KEY_BUTTON_NUM > 6) || (__KEY_ARRAY_NUM > 6)
#define     __KEYPADS_KEY7_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY7_PIN_NUM      (11U)
#define     __KEYPADS_KEY7_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY7_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY7_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY7_NVIC_PRE     (0)
#define     __KEYPADS_KEY7_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 6) || (__KEY_ARRAY_NUM > 6)

#if (__KEY_BUTTON_NUM > 7) || (__KEY_ARRAY_NUM > 7)
#define     __KEYPADS_KEY8_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY8_PIN_NUM      (11U)
#define     __KEYPADS_KEY8_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY8_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY8_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY8_NVIC_PRE     (0)
#define     __KEYPADS_KEY8_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 7) || (__KEY_ARRAY_NUM > 7)

#if (__KEY_BUTTON_NUM > 8) || (__KEY_ARRAY_NUM > 8)
#define     __KEYPADS_KEY9_PORT_BASE    (GPIOB_BASE)
#define     __KEYPADS_KEY9_PIN_NUM      (11U)
#define     __KEYPADS_KEY9_IRQ_MODE     (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY9_INITSTATUS   (__INIT_HIGH)
#define     __KEYPADS_KEY9_NVIC_PG      (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY9_NVIC_PRE     (0)
#define     __KEYPADS_KEY9_NVIC_SUB     (0)
#endif // (__KEY_BUTTON_NUM > 8) || (__KEY_ARRAY_NUM > 8)

#if (__KEY_BUTTON_NUM > 9) || (__KEY_ARRAY_NUM > 9)
#define     __KEYPADS_KEY10_PORT_BASE   (GPIOB_BASE)
#define     __KEYPADS_KEY10_PIN_NUM     (11U)
#define     __KEYPADS_KEY10_IRQ_MODE    (__FALLING_EDGE_TRIGGER)
#define     __KEYPADS_KEY10_INITSTATUS  (__INIT_HIGH)
#define     __KEYPADS_KEY10_NVIC_PG     (NVIC_PriorityGroup_0)
#define     __KEYPADS_KEY10_NVIC_PRE    (0)
#define     __KEYPADS_KEY10_NVIC_SUB    (0)
#endif // (__KEY_BUTTON_NUM > 9) || (__KEY_ARRAY_NUM > 9)

#if (__KEY_ARRAY == __KEYPADS_INTERFACE)
#define     __KEY_TURN_ON        (0x0021u)  // K1 2��1��
#define     __KEY_MODE           (0x0031u)  // K2 3��1��
#define     __KEY_VOLUME         (0x0032u)  // K4 3��2��
#define     __KEY_ADVANCED       (0x0012u)  // K3 1��2��
#define     __KEY_UP             (0x0013u)  // K5 1��3��
#define     __KEY_LOW            (0x0023u)  // K6 2��3��
#elif (__KEY_BUTTON == __KEYPADS_INTERFACE)
#else
#error Wrong KeyPads Interfaces!!
#endif

#endif

#if (1) // PROJECT PERIPHERALS
#define     __REVOBOX_IN_STUDYING             (0x00u)
#define     __REVOBOX_IN_AP                   (0x01u)

/**** Ethernet Interface ******************************************************/
extern void rvcmGateWaySyncRoutine (void);
#define     __RVCM_ETH_TIM_CALLBACK           NULL // */ rvcmGateWaySyncRoutine

#define     PHY_ADDRESS                       0x01 /* Relative to STM3210C-EVAL Board */

#define     __ETH_GPIO_VER                    (1) // 0 :: OLD, REMAPPED, 1 :: NEW, UNREMAPPED

#define     __ETH_MCO_PORT                    (io_Port_A)
#define     __ETH_MCO_PIN                     (io_Pin_08)
#define     __ETH_MCO_PIN_MODE                (io_Mode_APP)
#define     __ETH_MCO_PIN_SPEED               (is_50MHz)
#define     __ETH_MCO_INIT_STATUS             (IO_is_Low)

#define     __ETH_PHY_nRST_PORT               (io_Port_A) // nRST is active low
#define     __ETH_PHY_nRST_PIN                (io_Pin_06)
#define     __ETH_PHY_nRST_PIN_MODE           (io_Mode_OOP)
#define     __ETH_PHY_nRST_PIN_SPEED          (is_50MHz)
#define     __ETH_PHY_nRST_INIT_STATUS        (IO_is_High)

#if (0 == __ETH_GPIO_VER)

#define     __ETH_RMII_TXEN_PORT            (io_Port_1)
#define     __ETH_RMII_TXEN_PIN             (io_Pin_11)
#define     __ETH_RMII_TXEN_PIN_MODE        (io_Mode_APP)
#define     __ETH_RMII_TXEN_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_TXEN_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_TXD0_PORT            (io_Port_1)
#define     __ETH_RMII_TXD0_PIN             (io_Pin_12)
#define     __ETH_RMII_TXD0_PIN_MODE        (io_Mode_APP)
#define     __ETH_RMII_TXD0_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_TXD0_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_TXD1_PORT            (io_Port_1)
#define     __ETH_RMII_TXD1_PIN             (io_Pin_13)
#define     __ETH_RMII_TXD1_PIN_MODE        (io_Mode_APP)
#define     __ETH_RMII_TXD1_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_TXD1_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_RXD0_PORT            (io_Port_3)
#define     __ETH_RMII_RXD0_PIN             (io_Pin_09)
#define     __ETH_RMII_RXD0_PIN_MODE        (io_Mode_FIN)
#define     __ETH_RMII_RXD0_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_RXD0_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_RXD1_PORT            (io_Port_3)
#define     __ETH_RMII_RXD1_PIN             (io_Pin_10)
#define     __ETH_RMII_RXD1_PIN_MODE        (io_Mode_FIN)
#define     __ETH_RMII_RXD1_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_RXD1_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_CRSDV_PORT           (io_Port_3)
#define     __ETH_RMII_CRSDV_PIN            (io_Pin_08)
#define     __ETH_RMII_CRSDV_PIN_MODE       (io_Mode_FIN)
#define     __ETH_RMII_CRSDV_PIN_SPEED      (is_50MHz)
#define     __ETH_RMII_CRSDV_INIT_STATUS    (IO_is_Low)

#define     __ETH_RMII_MDC_PORT             (io_Port_2)
#define     __ETH_RMII_MDC_PIN              (io_Pin_01)
#define     __ETH_RMII_MDC_PIN_MODE         (io_Mode_APP)
#define     __ETH_RMII_MDC_PIN_SPEED        (is_50MHz)
#define     __ETH_RMII_MDC_INIT_STATUS      (IO_is_Low)

#define     __ETH_RMII_MDIO_PORT            (io_Port_0)
#define     __ETH_RMII_MDIO_PIN             (io_Pin_02)
#define     __ETH_RMII_MDIO_PIN_MODE        (io_Mode_APP)
#define     __ETH_RMII_MDIO_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_MDIO_INIT_STATUS     (IO_is_Low)

#define     __ETH_RMII_RCLK_PORT            (io_Port_0)
#define     __ETH_RMII_RCLK_PIN             (io_Pin_01)
#define     __ETH_RMII_RCLK_PIN_MODE        (io_Mode_FIN)
#define     __ETH_RMII_RCLK_PIN_SPEED       (is_50MHz)
#define     __ETH_RMII_RCLK_INIT_STATUS     (IO_is_Low)

#elif (1 == __ETH_GPIO_VER)

#define     __ETH_RMII_TXEN_PORT              (io_Port_B)
#define     __ETH_RMII_TXEN_PIN               (io_Pin_11)
#define     __ETH_RMII_TXEN_PIN_MODE          (io_Mode_APP)
#define     __ETH_RMII_TXEN_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_TXEN_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_TXD0_PORT              (io_Port_B)
#define     __ETH_RMII_TXD0_PIN               (io_Pin_12)
#define     __ETH_RMII_TXD0_PIN_MODE          (io_Mode_APP)
#define     __ETH_RMII_TXD0_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_TXD0_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_TXD1_PORT              (io_Port_B)
#define     __ETH_RMII_TXD1_PIN               (io_Pin_13)
#define     __ETH_RMII_TXD1_PIN_MODE          (io_Mode_APP)
#define     __ETH_RMII_TXD1_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_TXD1_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_RXD0_PORT              (io_Port_C)
#define     __ETH_RMII_RXD0_PIN               (io_Pin_04)
#define     __ETH_RMII_RXD0_PIN_MODE          (io_Mode_FIN)
#define     __ETH_RMII_RXD0_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_RXD0_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_RXD1_PORT              (io_Port_C)
#define     __ETH_RMII_RXD1_PIN               (io_Pin_05)
#define     __ETH_RMII_RXD1_PIN_MODE          (io_Mode_FIN)
#define     __ETH_RMII_RXD1_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_RXD1_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_CRSDV_PORT             (io_Port_A)
#define     __ETH_RMII_CRSDV_PIN              (io_Pin_07)
#define     __ETH_RMII_CRSDV_PIN_MODE         (io_Mode_FIN)
#define     __ETH_RMII_CRSDV_PIN_SPEED        (is_50MHz)
#define     __ETH_RMII_CRSDV_INIT_STATUS      (IO_is_Low)

#define     __ETH_RMII_MDC_PORT               (io_Port_C)
#define     __ETH_RMII_MDC_PIN                (io_Pin_01)
#define     __ETH_RMII_MDC_PIN_MODE           (io_Mode_APP)
#define     __ETH_RMII_MDC_PIN_SPEED          (is_50MHz)
#define     __ETH_RMII_MDC_INIT_STATUS        (IO_is_Low)

#define     __ETH_RMII_MDIO_PORT              (io_Port_A)
#define     __ETH_RMII_MDIO_PIN               (io_Pin_02)
#define     __ETH_RMII_MDIO_PIN_MODE          (io_Mode_APP)
#define     __ETH_RMII_MDIO_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_MDIO_INIT_STATUS       (IO_is_Low)

#define     __ETH_RMII_RCLK_PORT              (io_Port_A)
#define     __ETH_RMII_RCLK_PIN               (io_Pin_01)
#define     __ETH_RMII_RCLK_PIN_MODE          (io_Mode_FIN)
#define     __ETH_RMII_RCLK_PIN_SPEED         (is_50MHz)
#define     __ETH_RMII_RCLK_INIT_STATUS       (IO_is_Low)

#endif

#endif // project peripherals

#endif // defined _USE_GLOBAL_PROJECT_CONFIGURATION

/**** Includes ****************************************************************/
#include "./Proj_cfg/inc/projAssert.h"

#endif // __PROJECT_CONFIGURATION_H_20191203YK
